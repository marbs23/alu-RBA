module clk_divider #(parameter DIV = 50000000)(
    input clk, rst,
    output reg slow_clk
);
    reg [31:0] counter = 0;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter == DIV) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule


module top_FP_ALU_Basys3(
    input clk, rst,
    input [15:0] sw,
    input btnC, btnR, btnU,
    output [15:0] led
);
    wire slow_clk;
    clk_divider #(25000000) div(clk, rst, slow_clk);

    // FSM states
    localparam S0=3'd0, S1=3'd1, S2=3'd2, S3=3'd3, S4=3'd4, S5=3'd5, S6=3'd6;
    reg [2:0] state = S0;

    // Se침ales internas
    reg [31:0] op_a, op_b;
    reg [1:0]  op_code;
    reg start;
    wire [31:0] result;
    wire [4:0]  flags;
    wire valid_out;

    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(slow_clk),
        .rst(rst),
        .start(start),
        .mode_fp(1'b1),  // 1 = single precision (FP32)
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    always @(posedge slow_clk or posedge rst) begin
        if (rst) begin
            state <= S0;
            start <= 0;
            op_a <= 0;
            op_b <= 0;
        end else begin
            case (state)
                S0: if (btnC) begin op_a[15:0] <= sw; state <= S1; end
                S1: if (btnC) begin op_a[31:16] <= sw; state <= S2; end
                S2: if (btnC) begin op_b[15:0] <= sw; state <= S3; end
                S3: if (btnC) begin op_b[31:16] <= sw; state <= S4; end
                S4: if (btnC) begin op_code <= sw[1:0]; start <= 1; state <= S5; end
                S5: begin
                        start <= 0;
                        if (valid_out) state <= S6;
                    end
                S6: if (btnR) state <= S0;
            endcase
        end
    end



    reg btnU_sync0, btnU_sync1;
    reg show_upper = 0;

    always @(posedge slow_clk or posedge rst) begin
        if (rst) begin
            btnU_sync0 <= 0;
            btnU_sync1 <= 0;
        end else begin
            btnU_sync0 <= btnU;
            btnU_sync1 <= btnU_sync0;
        end
    end

    wire btnU_rise = (btnU_sync0 & ~btnU_sync1);

    always @(posedge slow_clk or posedge rst) begin
        if (rst)
            show_upper <= 0;
        else if (btnU_rise)
            show_upper <= ~show_upper;
    end

    assign led = show_upper ? result[31:16] : result[15:0];

endmodule



module FP_ALU_if (
    input  [31:0] op_a, op_b,
    input  [1:0]  op_code,        
    input         clk, rst,
    input         start,
    input         mode_fp,        
    output reg [31:0] result,
    output reg [4:0]  flags,      
    output reg        valid_out
);

    wire [7:0] bias_sel     = mode_fp ? 8'd15  : 8'd127;
    wire [7:0] exp_max_sel  = mode_fp ? 8'd30  : 8'd254;
    wire [7:0] exp_min_sel  = 8'd1;

    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;
    reg [24:0] mant_sum;
    reg [7:0]  exp_diff;
    reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;
    reg [47:0] q, div_numer, remainder;
    reg [22:0] frac_div;
    reg [23:0] frac_round;
    reg guard_bit, sticky_bit, lsb_bit;
    reg round_inc, overflow, underflow;
    reg [47:0] product;
    reg [22:0] frac_mul;
    reg did_round;


    always @(*) begin
        result     = 32'b0;
        flags      = 5'b00000;
        valid_out  = 1'b0;

        if (mode_fp) begin
            sign_a = op_a[15];
            sign_b = op_b[15];
            exp_a  = {3'b000, op_a[14:10]};
            exp_b  = {3'b000, op_b[14:10]};
            mant_a = (exp_a[4:0]==5'd0) ? {1'b0, op_a[9:0], 13'b0} : {1'b1, op_a[9:0], 13'b0};
            mant_b = (exp_b[4:0]==5'd0) ? {1'b0, op_b[9:0], 13'b0} : {1'b1, op_b[9:0], 13'b0};

            a_is_nan  = (exp_a[4:0]==5'h1F) && (op_a[9:0]!=0);
            b_is_nan  = (exp_b[4:0]==5'h1F) && (op_b[9:0]!=0);
            a_is_inf  = (exp_a[4:0]==5'h1F) && (op_a[9:0]==0);
            b_is_inf  = (exp_b[4:0]==5'h1F) && (op_b[9:0]==0);
            a_is_zero = (exp_a[4:0]==5'd0)  && (op_a[9:0]==0);
            b_is_zero = (exp_b[4:0]==5'd0)  && (op_b[9:0]==0);
        end else begin
            sign_a = op_a[31];
            sign_b = op_b[31];
            exp_a  = op_a[30:23];
            exp_b  = op_b[30:23];
            mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
            mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

            a_is_nan  = (exp_a==8'hFF) && (op_a[22:0]!=0);
            b_is_nan  = (exp_b==8'hFF) && (op_b[22:0]!=0);
            a_is_inf  = (exp_a==8'hFF) && (op_a[22:0]==0);
            b_is_inf  = (exp_b==8'hFF) && (op_b[22:0]==0);
            a_is_zero = (exp_a==8'd0)  && (op_a[22:0]==0);
            b_is_zero = (exp_b==8'd0)  && (op_b[22:0]==0);
        end

        case (op_code)
 
        2'b00, 2'b01: begin

            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1; // invalid
            end else if (a_is_inf && b_is_inf && (sign_a != (op_code==2'b01 ? ~sign_b : sign_b))) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else begin
                if (op_code == 2'b01) sign_b = ~sign_b;

                if (exp_a > exp_b) begin
                    exp_diff = exp_a - exp_b;
                    mant_b = mant_b >> exp_diff;
                    exp_res = exp_a;
                end else if (exp_b > exp_a) begin
                    exp_diff = exp_b - exp_a;
                    mant_a = mant_a >> exp_diff;
                    exp_res = exp_b;
                end else begin
                    exp_res = exp_a;
                end

                if (sign_a == sign_b) begin
                    mant_sum = mant_a + mant_b;
                    sign_res = sign_a;
                end else begin
                    if (mant_a >= mant_b) begin
                        mant_sum = mant_a - mant_b;
                        sign_res = sign_a;
                    end else begin
                        mant_sum = mant_b - mant_a;
                        sign_res = sign_b;
                    end
                end

                if (mant_sum[24]) begin
                    mant_sum = mant_sum >> 1;
                    exp_res  = exp_res + 1;
                end else if (!mant_sum[23] && mant_sum != 0) begin
                    mant_sum = mant_sum << 1;
                    exp_res  = exp_res - 1;
                end

                guard_bit = mant_sum[0];
                lsb_bit   = mant_sum[1];
                did_round = guard_bit & ~lsb_bit;

                flags[2] = (exp_res > exp_max_sel);
                flags[1] = (exp_res < exp_min_sel);
                flags[0] = did_round | guard_bit;  

                if (flags[2])
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (flags[1] || mant_sum==0)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], mant_sum[22:13]};
                else
                    result = {sign_res, exp_res[7:0], mant_sum[22:0]};
            end
        end

   
        2'b10: begin
           

            if (a_is_nan || b_is_nan || (a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (a_is_inf || b_is_inf) begin
                sign_res = sign_a ^ sign_b;
                result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
            end else if (a_is_zero || b_is_zero) begin
                result = {sign_a ^ sign_b, 31'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                product = mant_a * mant_b;
                exp_res = exp_a + exp_b - bias_sel;

                if (product[47]) begin
                    product = product >> 1;
                    exp_res = exp_res + 1;
                end

                frac_mul = product[45:23];
                lsb_bit = product[23];
                guard_bit = product[22];
                sticky_bit = |product[21:0];
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_mul} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow;
                flags[1] = underflow;
                flags[0] = round_inc;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end


        2'b11: begin
           

            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if ((a_is_zero && b_is_zero) || (a_is_inf && b_is_inf)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (b_is_zero) begin
                flags[3] = 1'b1; // div0
                result = mode_fp ? {16'b0, sign_a ^ sign_b, 5'h1F, 10'd0} : {sign_a ^ sign_b, 8'hFF, 23'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                div_numer = {mant_a, 24'b0};
                q = div_numer / mant_b;
                remainder = div_numer % mant_b;
                exp_res = (exp_a - exp_b) + bias_sel;

                if (q[25]) begin
                    q = q >> 1;
                    exp_res = exp_res + 1;
                end else if (!q[24]) begin
                    q = q << 1;
                    exp_res = exp_res - 1;
                end

                frac_div = q[23:1];
                lsb_bit = q[1];
                guard_bit = q[0];
                sticky_bit = (remainder != 0);
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_div} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow;
                flags[1] = underflow;
                flags[0] = guard_bit | sticky_bit;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end
        endcase

        valid_out = start;
    end
endmodule



## ======= BUTTONS =======
# Bot칩n central -> confirmar / avanzar FSM
#set_property PACKAGE_PIN U18 [get_ports btnC]
#set_property IOSTANDARD LVCMOS33 [get_ports btnC]

# Bot칩n derecho -> reset FSM
#set_property PACKAGE_PIN T17 [get_ports btnR]
#set_property IOSTANDARD LVCMOS33 [get_ports btnR]

# Bot칩n superior -> alternar alta/baja resultado
#set_property PACKAGE_PIN T18 [get_ports btnU]
#set_property IOSTANDARD LVCMOS33 [get_ports btnU]

## This file is a general .xdc for the Basys3 rev B board
## To use it in a project:
## - uncomment the lines corresponding to used pins
## - rename the used ports (in each line, after get_ports) according to the top level signal names in the project

## Clock signal
set_property PACKAGE_PIN W5 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports clk]
 
## Switches
set_property PACKAGE_PIN V17 [get_ports {sw[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[0]}]
set_property PACKAGE_PIN V16 [get_ports {sw[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[1]}]
set_property PACKAGE_PIN W16 [get_ports {sw[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[2]}]
set_property PACKAGE_PIN W17 [get_ports {sw[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[3]}]
set_property PACKAGE_PIN W15 [get_ports {sw[4]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[4]}]
set_property PACKAGE_PIN V15 [get_ports {sw[5]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[5]}]
set_property PACKAGE_PIN W14 [get_ports {sw[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[6]}]
set_property PACKAGE_PIN W13 [get_ports {sw[7]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[7]}]
set_property PACKAGE_PIN V2 [get_ports {sw[8]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[8]}]
set_property PACKAGE_PIN T3 [get_ports {sw[9]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[9]}]
set_property PACKAGE_PIN T2 [get_ports {sw[10]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[10]}]
set_property PACKAGE_PIN R3 [get_ports {sw[11]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[11]}]
set_property PACKAGE_PIN W2 [get_ports {sw[12]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[12]}]
set_property PACKAGE_PIN U1 [get_ports {sw[13]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[13]}]
set_property PACKAGE_PIN T1 [get_ports {sw[14]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[14]}]
set_property PACKAGE_PIN R2 [get_ports {sw[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[15]}]
 

## LEDs
set_property PACKAGE_PIN U16 [get_ports {led[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[0]}]
set_property PACKAGE_PIN E19 [get_ports {led[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[1]}]
set_property PACKAGE_PIN U19 [get_ports {led[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[2]}]
set_property PACKAGE_PIN V19 [get_ports {led[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[3]}]
set_property PACKAGE_PIN W18 [get_ports {led[4]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[4]}]
set_property PACKAGE_PIN U15 [get_ports {led[5]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[5]}]
set_property PACKAGE_PIN U14 [get_ports {led[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[6]}]
set_property PACKAGE_PIN V14 [get_ports {led[7]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[7]}]
set_property PACKAGE_PIN V13 [get_ports {led[8]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[8]}]
set_property PACKAGE_PIN V3 [get_ports {led[9]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[9]}]
set_property PACKAGE_PIN W3 [get_ports {led[10]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[10]}]
set_property PACKAGE_PIN U3 [get_ports {led[11]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[11]}]
set_property PACKAGE_PIN P3 [get_ports {led[12]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[12]}]
set_property PACKAGE_PIN N3 [get_ports {led[13]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[13]}]
set_property PACKAGE_PIN P1 [get_ports {led[14]}]
    set_property IOSTANDARD LVCMOS33 [get_ports {led[14]}]
set_property PACKAGE_PIN L1 [get_ports {led[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[15]}]


##7 segment display
#set_property PACKAGE_PIN W7 [get_ports {seg[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[0]}]
#set_property PACKAGE_PIN W6 [get_ports {seg[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[1]}]
#set_property PACKAGE_PIN U8 [get_ports {seg[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[2]}]
#set_property PACKAGE_PIN V8 [get_ports {seg[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[3]}]
#set_property PACKAGE_PIN U5 [get_ports {seg[4]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[4]}]
#set_property PACKAGE_PIN V5 [get_ports {seg[5]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[5]}]
#set_property PACKAGE_PIN U7 [get_ports {seg[6]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {seg[6]}]

#set_property PACKAGE_PIN V7 [get_ports dp]
#set_property IOSTANDARD LVCMOS33 [get_ports dp]

#set_property PACKAGE_PIN U2 [get_ports {an[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {an[0]}]
#set_property PACKAGE_PIN U4 [get_ports {an[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {an[1]}]
#set_property PACKAGE_PIN V4 [get_ports {an[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {an[2]}]
#set_property PACKAGE_PIN W4 [get_ports {an[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {an[3]}]


##Buttons
set_property PACKAGE_PIN U18 [get_ports btnC]
set_property IOSTANDARD LVCMOS33 [get_ports btnC]
set_property PACKAGE_PIN T18 [get_ports btnU]
set_property IOSTANDARD LVCMOS33 [get_ports btnU]
#set_property PACKAGE_PIN W19 [get_ports btnL]
#set_property IOSTANDARD LVCMOS33 [get_ports btnL]
set_property PACKAGE_PIN T17 [get_ports btnR]
set_property IOSTANDARD LVCMOS33 [get_ports btnR]
set_property PACKAGE_PIN U17 [get_ports rst]
set_property IOSTANDARD LVCMOS33 [get_ports rst]
 


##Pmod Header JA
##Sch name = JA1
#set_property PACKAGE_PIN J1 [get_ports {JA[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[0]}]
##Sch name = JA2
#set_property PACKAGE_PIN L2 [get_ports {JA[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[1]}]
##Sch name = JA3
#set_property PACKAGE_PIN J2 [get_ports {JA[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[2]}]
##Sch name = JA4
#set_property PACKAGE_PIN G2 [get_ports {JA[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[3]}]
##Sch name = JA7
#set_property PACKAGE_PIN H1 [get_ports {JA[4]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[4]}]
##Sch name = JA8
#set_property PACKAGE_PIN K2 [get_ports {JA[5]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[5]}]
##Sch name = JA9
#set_property PACKAGE_PIN H2 [get_ports {JA[6]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[6]}]
##Sch name = JA10
#set_property PACKAGE_PIN G3 [get_ports {JA[7]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JA[7]}]



##Pmod Header JB
##Sch name = JB1
#set_property PACKAGE_PIN A14 [get_ports {JB[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[0]}]
##Sch name = JB2
#set_property PACKAGE_PIN A16 [get_ports {JB[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[1]}]
##Sch name = JB3
#set_property PACKAGE_PIN B15 [get_ports {JB[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[2]}]
##Sch name = JB4
#set_property PACKAGE_PIN B16 [get_ports {JB[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[3]}]
##Sch name = JB7
#set_property PACKAGE_PIN A15 [get_ports {JB[4]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[4]}]
##Sch name = JB8
#set_property PACKAGE_PIN A17 [get_ports {JB[5]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[5]}]
##Sch name = JB9
#set_property PACKAGE_PIN C15 [get_ports {JB[6]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[6]}]
##Sch name = JB10
#set_property PACKAGE_PIN C16 [get_ports {JB[7]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JB[7]}]
 


##Pmod Header JC
##Sch name = JC1
#set_property PACKAGE_PIN K17 [get_ports {JC[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[0]}]
##Sch name = JC2
#set_property PACKAGE_PIN M18 [get_ports {JC[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[1]}]
##Sch name = JC3
#set_property PACKAGE_PIN N17 [get_ports {JC[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[2]}]
##Sch name = JC4
#set_property PACKAGE_PIN P18 [get_ports {JC[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[3]}]
##Sch name = JC7
#set_property PACKAGE_PIN L17 [get_ports {JC[4]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[4]}]
##Sch name = JC8
#set_property PACKAGE_PIN M19 [get_ports {JC[5]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[5]}]
##Sch name = JC9
#set_property PACKAGE_PIN P17 [get_ports {JC[6]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[6]}]
##Sch name = JC10
#set_property PACKAGE_PIN R18 [get_ports {JC[7]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JC[7]}]


##Pmod Header JXADC
##Sch name = XA1_P
#set_property PACKAGE_PIN J3 [get_ports {JXADC[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[0]}]
##Sch name = XA2_P
#set_property PACKAGE_PIN L3 [get_ports {JXADC[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[1]}]
##Sch name = XA3_P
#set_property PACKAGE_PIN M2 [get_ports {JXADC[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[2]}]
##Sch name = XA4_P
#set_property PACKAGE_PIN N2 [get_ports {JXADC[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[3]}]
##Sch name = XA1_N
#set_property PACKAGE_PIN K3 [get_ports {JXADC[4]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[4]}]
##Sch name = XA2_N
#set_property PACKAGE_PIN M3 [get_ports {JXADC[5]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[5]}]
##Sch name = XA3_N
#set_property PACKAGE_PIN M1 [get_ports {JXADC[6]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[6]}]
##Sch name = XA4_N
#set_property PACKAGE_PIN N1 [get_ports {JXADC[7]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {JXADC[7]}]



##VGA Connector
#set_property PACKAGE_PIN G19 [get_ports {vgaRed[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaRed[0]}]
#set_property PACKAGE_PIN H19 [get_ports {vgaRed[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaRed[1]}]
#set_property PACKAGE_PIN J19 [get_ports {vgaRed[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaRed[2]}]
#set_property PACKAGE_PIN N19 [get_ports {vgaRed[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaRed[3]}]
#set_property PACKAGE_PIN N18 [get_ports {vgaBlue[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaBlue[0]}]
#set_property PACKAGE_PIN L18 [get_ports {vgaBlue[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaBlue[1]}]
#set_property PACKAGE_PIN K18 [get_ports {vgaBlue[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaBlue[2]}]
#set_property PACKAGE_PIN J18 [get_ports {vgaBlue[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaBlue[3]}]
#set_property PACKAGE_PIN J17 [get_ports {vgaGreen[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaGreen[0]}]
#set_property PACKAGE_PIN H17 [get_ports {vgaGreen[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaGreen[1]}]
#set_property PACKAGE_PIN G17 [get_ports {vgaGreen[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaGreen[2]}]
#set_property PACKAGE_PIN D17 [get_ports {vgaGreen[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {vgaGreen[3]}]
#set_property PACKAGE_PIN P19 [get_ports Hsync]
#set_property IOSTANDARD LVCMOS33 [get_ports Hsync]
#set_property PACKAGE_PIN R19 [get_ports Vsync]
#set_property IOSTANDARD LVCMOS33 [get_ports Vsync]


##USB-RS232 Interface
#set_property PACKAGE_PIN B18 [get_ports RsRx]
#set_property IOSTANDARD LVCMOS33 [get_ports RsRx]
#set_property PACKAGE_PIN A18 [get_ports RsTx]
#set_property IOSTANDARD LVCMOS33 [get_ports RsTx]


##USB HID (PS/2)
#set_property PACKAGE_PIN C17 [get_ports PS2Clk]
#set_property IOSTANDARD LVCMOS33 [get_ports PS2Clk]
#set_property PULLUP true [get_ports PS2Clk]
#set_property PACKAGE_PIN B17 [get_ports PS2Data]
#set_property IOSTANDARD LVCMOS33 [get_ports PS2Data]
#set_property PULLUP true [get_ports PS2Data]


##Quad SPI Flash
##Note that CCLK_0 cannot be placed in 7 series devices. You can access it using the
##STARTUPE2 primitive.
#set_property PACKAGE_PIN D18 [get_ports {QspiDB[0]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {QspiDB[0]}]
#set_property PACKAGE_PIN D19 [get_ports {QspiDB[1]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {QspiDB[1]}]
#set_property PACKAGE_PIN G18 [get_ports {QspiDB[2]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {QspiDB[2]}]
#set_property PACKAGE_PIN F18 [get_ports {QspiDB[3]}]
#set_property IOSTANDARD LVCMOS33 [get_ports {QspiDB[3]}]
#set_property PACKAGE_PIN K19 [get_ports QspiCSn]
#set_property IOSTANDARD LVCMOS33 [get_ports QspiCSn]
