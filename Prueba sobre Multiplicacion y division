

`timescale 1ns/1ps

module FP_ALU_if (
    input  [31:0] op_a, op_b,  
    input  [1:0]  op_code,  
    output reg [31:0] result
);
    // Decompose operands
    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;
    reg [24:0] mant_result;
    reg [7:0] exp_diff;
    reg carry;

    always @(*) begin
        // 1. Decompose inputs
        sign_a = op_a[31];
        sign_b = op_b[31];
        exp_a  = op_a[30:23];
        exp_b  = op_b[30:23];
        mant_a = {1'b1, op_a[22:0]};
        mant_b = {1'b1, op_b[22:0]};

        // 2. Defaults
        sign_res = 0;
        exp_res  = 0;
        mant_result = 0;
        carry    = 0;

        // 3. Decode operation
        casex (op_code)
            2'b0?: 
            begin   // ADD / SUB
                // If subtraction, flip sign_b
                if (op_code == 2'b01)
                    sign_b = ~sign_b;

                case ({(exp_a > exp_b), (exp_a < exp_b)})
                    2'b10: 
                    begin 
                        exp_diff = exp_a - exp_b;
                        mant_b = mant_b >> exp_diff;
                        exp_res = exp_a;
                    end
                    2'b01: begin 
                        exp_diff = exp_b - exp_a;
                        mant_a = mant_a >> exp_diff;
                        exp_res = exp_b;
                    end
                    default: begin 
                        exp_res = exp_a;
                    end
                endcase

                case ({sign_a, sign_b})
                    2'b00, 2'b11: begin
                        mant_result = mant_a + mant_b;
                        sign_res = sign_a;  // same sign
                    end
                    2'b01: begin
                        if (mant_a >= mant_b) begin
                            mant_result = mant_a - mant_b;
                            sign_res = 1'b0; // A positive
                        end else begin
                            mant_result = mant_b - mant_a;
                            sign_res = 1'b1; // B negative
                        end
                    end
                    2'b10: begin
                        if (mant_a >= mant_b) begin
                            mant_result = mant_a - mant_b;
                            sign_res = 1'b1; // A negative
                        end else begin
                            mant_result = mant_b - mant_a;
                            sign_res = 1'b0; // B positive
                        end
                    end
                endcase

                if (mant_result[24]) begin
                    mant_result = mant_result >> 1;
                    exp_res = exp_res + 1;
                end else begin
                    while (mant_result[23] == 0 && exp_res > 0) begin
                        mant_result = mant_result << 1;
                        exp_res  = exp_res - 1;
                    end
                end
            end
            2'b10: 
            begin

                sign_res = sign_a ^ sign_b;
                exp_res = exp_a + exp_b - 127; 
                mant_result = (mant_a * mant_b) >> 23;

            end

            2'b11: 

            begin
                sign_res = sign_a ^ sign_b;
                exp_res = exp_a - exp_b + 127;
                mant_result = (mant_a << 23) / mant_b; 

            end


            default: begin
                sign_res = 0;
                exp_res  = 0;
                mant_result = 0;
            end
        endcase

        result = {sign_res, exp_res[7:0], mant_result[22:0]};
    end
endmodule
