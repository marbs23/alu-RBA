
module FP_ALU_if (
    input  [31:0] op_a, op_b,
    input  [1:0]  op_code,        
    input         clk, rst,
    input         start,
    input         mode_fp,      
    output reg [31:0] result,
    output reg [4:0]  flags,      
    output reg        valid_out
);
    wire [7:0] bias_sel     = mode_fp ? 8'd15  : 8'd127;
    wire [7:0] exp_max_sel  = mode_fp ? 8'd30  : 8'd254;
    wire [7:0] exp_min_sel  = 8'd1;

    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;
    reg [24:0] mant_sum;
    reg [7:0]  exp_diff;
    reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;
    reg [47:0] product, q, div_numer, remainder;
    reg [22:0] frac_div, frac_mul;
    reg [23:0] frac_round;
    reg guard_bit, sticky_bit, lsb_bit, round_inc, overflow, underflow, did_round;

    always @(*) begin
        result     = 32'b0;
        flags      = 5'b00000;
        valid_out  = 1'b0;

   
       if (mode_fp) begin
            sign_a = op_a[15];
            sign_b = op_b[15];
            exp_a  = {3'b000, op_a[14:10]};
            exp_b  = {3'b000, op_b[14:10]};
            mant_a = (exp_a[4:0]==5'd0) ? {1'b0, op_a[9:0], 13'b0} : {1'b1, op_a[9:0], 13'b0};
            mant_b = (exp_b[4:0]==5'd0) ? {1'b0, op_b[9:0], 13'b0} : {1'b1, op_b[9:0], 13'b0};

            a_is_nan  = (exp_a[4:0]==5'h1F) && (op_a[9:0]!=0);
            b_is_nan  = (exp_b[4:0]==5'h1F) && (op_b[9:0]!=0);
            a_is_inf  = (exp_a[4:0]==5'h1F) && (op_a[9:0]==0);
            b_is_inf  = (exp_b[4:0]==5'h1F) && (op_b[9:0]==0);
            a_is_zero = (exp_a[4:0]==5'd0)  && (op_a[9:0]==0);
            b_is_zero = (exp_b[4:0]==5'd0)  && (op_b[9:0]==0);
        end else begin
            sign_a = op_a[31];
            sign_b = op_b[31];
            exp_a  = op_a[30:23];
            exp_b  = op_b[30:23];
            mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
            mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

            a_is_nan  = (exp_a==8'hFF) && (op_a[22:0]!=0);
            b_is_nan  = (exp_b==8'hFF) && (op_b[22:0]!=0);
            a_is_inf  = (exp_a==8'hFF) && (op_a[22:0]==0);
            b_is_inf  = (exp_b==8'hFF) && (op_b[22:0]==0);
            a_is_zero = (exp_a==8'd0)  && (op_a[22:0]==0);
            b_is_zero = (exp_b==8'd0)  && (op_b[22:0]==0);
        end


        case (op_code)

  
        2'b00, 2'b01: begin
            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else begin
                reg eff_sign_b;
                eff_sign_b = (op_code == 2'b01) ? ~sign_b : sign_b;

                if (a_is_inf && b_is_inf) begin
                    if (sign_a != eff_sign_b) begin
                        result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                        flags[4] = 1'b1;
                    end else begin
                        result = mode_fp ? {16'b0, sign_a, 5'h1F, 10'd0}
                                         : {sign_a, 8'hFF, 23'd0};
                    end
                end else if (a_is_inf && !b_is_inf) begin
                    result = mode_fp ? {16'b0, sign_a, 5'h1F, 10'd0}
                                     : {sign_a, 8'hFF, 23'd0};
                end else if (!a_is_inf && b_is_inf) begin
                    result = mode_fp ? {16'b0, eff_sign_b, 5'h1F, 10'd0}
                                     : {eff_sign_b, 8'hFF, 23'd0};
                end else begin
                    reg [23:0] A, B; reg [7:0] Eres; reg [24:0] S; reg Ssign;
                    A = mant_a; B = mant_b;

                    if (exp_a > exp_b) begin
                        B = B >> (exp_a - exp_b);
                        Eres = exp_a;
                    end else if (exp_b > exp_a) begin
                        A = A >> (exp_b - exp_a);
                        Eres = exp_b;
                    end else Eres = exp_a;

                    if (sign_a == eff_sign_b) begin
                        S = A + B; Ssign = sign_a;
                    end else begin
                        if (A >= B) begin
                            S = A - B; Ssign = sign_a;
                        end else begin
                            S = B - A; Ssign = eff_sign_b;
                        end
                    end

                    if (S[24]) begin
                        S = S >> 1; Eres = Eres + 1;
                    end else if (!S[23] && S != 0) begin
                        while (!S[23] && Eres > 0) begin
                            S = S << 1; Eres = Eres - 1;
                        end
                    end

                    guard_bit = S[0]; lsb_bit = S[1];
                    did_round = guard_bit & ~lsb_bit;
                    flags[2] = (Eres > exp_max_sel);
                    flags[1] = (Eres < exp_min_sel);
                    flags[0] = did_round | guard_bit;

                    if (flags[2])
                        result = mode_fp ? {16'b0, Ssign, 5'h1F, 10'd0}
                                         : {Ssign, 8'hFF, 23'd0};
                    else if (flags[1] || S==0)
                        result = {Ssign, 31'd0};
                    else if (mode_fp)
                        result = {16'b0, Ssign, Eres[4:0], S[22:13]};
                    else
                        result = {Ssign, Eres[7:0], S[22:0]};
                end
            end
        end


        2'b10: begin
            if (a_is_nan || b_is_nan || (a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (a_is_inf || b_is_inf) begin
                sign_res = sign_a ^ sign_b;
                result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0}
                                 : {sign_res, 8'hFF, 23'd0};
            end else if (a_is_zero || b_is_zero) begin
                result = {sign_a ^ sign_b, 31'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                product = mant_a * mant_b;
                exp_res = exp_a + exp_b - bias_sel;

                if (product[47]) begin
                    product = product >> 1; exp_res = exp_res + 1;
                end

                frac_mul = product[45:23];
                lsb_bit = product[23]; guard_bit = product[22];
                sticky_bit = |product[21:0];
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_mul} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1; exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow; flags[1] = underflow; flags[0] = round_inc;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0}
                                     : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end


        2'b11: begin
            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if ((a_is_zero && b_is_zero) || (a_is_inf && b_is_inf)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (b_is_zero) begin
                flags[3] = 1'b1;
                result = mode_fp ? {16'b0, sign_a ^ sign_b, 5'h1F, 10'd0}
                                 : {sign_a ^ sign_b, 8'hFF, 23'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                div_numer = {mant_a, 24'b0};
                q = div_numer / mant_b;
                remainder = div_numer % mant_b;
                exp_res = (exp_a - exp_b) + bias_sel;

                if (q[25]) begin q = q >> 1; exp_res = exp_res + 1; end
                else if (!q[24]) begin q = q << 1; exp_res = exp_res - 1; end

                frac_div = q[23:1];
                lsb_bit = q[1]; guard_bit = q[0];
                sticky_bit = (remainder != 0);
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_div} + round_inc;

                if (frac_round[23]) begin frac_round = frac_round >> 1; exp_res = exp_res + 1; end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow; flags[1] = underflow; flags[0] = guard_bit | sticky_bit;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0}
                                     : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end
        endcase

        valid_out = start;
    end
endmodule











`timescale 1ns/1ps

module tb_FP_ALU_if;

    reg  [31:0] op_a, op_b;
    reg  [1:0]  op_code;
    reg         start, mode_fp;
    reg         clk, rst;

    wire [31:0] result;
    wire [4:0]  flags;
    wire        valid_out;

    FP_ALU_if dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(clk),
        .rst(rst),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    always #5 clk = ~clk;

    initial begin
        $dumpfile("fp_alu_if_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if);

        clk = 0;
        rst = 1;
        start = 0;
        mode_fp = 1'b1; 
        op_a = 32'd0;
        op_b = 32'd0;
        op_code = 2'b00;

        #20 rst = 0;


      op_a = 32'h00007C00; op_b = 32'h00003C00; op_code = 2'b00; start = 1; 
      #10; start = 0; #40;

      op_a = 32'h0000FC00; op_b = 32'h0000BC00; op_code = 2'b01; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00007C00; op_b = 32'h0000FC00; op_code = 2'b00; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00003C00; op_b = 32'h00000000; op_code = 2'b11; start = 1; #10; start = 0;
      #100;

      op_a = 32'h00000000; op_b = 32'h00008000; op_code = 2'b00; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00000000; op_b = 32'h00008000; op_code = 2'b01; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00004000; op_b = 32'h00004000; op_code = 2'b10; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00003C00; op_b = 32'h00004000; op_code = 2'b11; start = 1; #10; start = 0;
      #100;

      op_a = 32'h00007E00; op_b = 32'h00003C00; op_code = 2'b00; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00003C00; op_b = 32'h00007E00; op_code = 2'b10; start = 1; #10; start = 0;
      #40;

      op_a = 32'h00007C00; op_b = 32'h00000000; op_code = 2'b10; start = 1; #10; start = 0;
      #40;

        #50;
        $finish;
    end

endmodule








`timescale 1ns/1ps

module tb_FP_ALU_if_FP32;

    reg  [31:0] op_a, op_b;
    reg  [1:0]  op_code;
    reg         start, mode_fp;
    reg         clk, rst;

    wire [31:0] result;
    wire [4:0]  flags;
    wire        valid_out;

    FP_ALU_if dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(clk),
        .rst(rst),
        .start(start),
        .mode_fp(mode_fp),  
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    always #5 clk = ~clk;

    initial begin
        $dumpfile("fp_alu_if_fp32_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if_FP32);

        clk = 0;
        rst = 1;
        start = 0;
        mode_fp = 1'b0; 
        op_a = 32'd0;
        op_b = 32'd0;
        op_code = 2'b00;

        #20 rst = 0;


     
        op_a = 32'h3F800000; op_b = 32'h40000000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h40000000; op_b = 32'h3F000000; op_code = 2'b01; start = 1; #10; start = 0; #40;  
        op_a = 32'h3F800000; op_b = 32'h3F800000; op_code = 2'b10; start = 1; #10; start = 0; #40;  
        op_a = 32'h40000000; op_b = 32'h3F800000; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'h7F800000; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40; 
        op_a = 32'hFF800000; op_b = 32'hBF800000; op_code = 2'b01; start = 1; #10; start = 0; #40;  
        op_a = 32'h7F800000; op_b = 32'hFF800000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h3F800000; op_b = 32'h00000000; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'h00000000; op_b = 32'h80000000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h00000000; op_b = 32'h80000000; op_code = 2'b01; start = 1; #10; start = 0; #40;  
        op_a = 32'h00000001; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40; 
        op_a = 32'h3F800000; op_b = 32'h00000001; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'h7FC00000; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h3F800000; op_b = 32'h7FC00000; op_code = 2'b10; start = 1; #10; start = 0; #40; 
        op_a = 32'h7F800000; op_b = 32'h00000000; op_code = 2'b10; start = 1; #10; start = 0; #40;  

        op_a = 32'hBF800000; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'hBF800000; op_b = 32'hBF800000; op_code = 2'b10; start = 1; #10; start = 0; #40;  
        op_a = 32'hBF800000; op_b = 32'h40000000; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'h7EFFFFFF; op_b = 32'h7EFFFFFF; op_code = 2'b10; start = 1; #10; start = 0; #40;  

        op_a = 32'h00800000; op_b = 32'h3F800000; op_code = 2'b10; start = 1; #10; start = 0; #40;  
        op_a = 32'h00800000; op_b = 32'h3F000000; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'hFF800000; op_b = 32'h7FC00000; op_code = 2'b00; start = 1; #10; start = 0; #40; 

        op_a = 32'h3F800000; op_b = 32'hFF800000; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        #100;
        $finish;
    end

endmodule





`timescale 1ns/1ps

module tb_FP_ALU_if_FP32;

    reg  [31:0] op_a, op_b;
    reg  [1:0]  op_code;
    reg         start, mode_fp;
    reg         clk, rst;

    wire [31:0] result;
    wire [4:0]  flags;
    wire        valid_out;

    FP_ALU_if dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(clk),
        .rst(rst),
        .start(start),
        .mode_fp(mode_fp),  
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    always #5 clk = ~clk;

    initial begin
        $dumpfile("fp_alu_if_fp32_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if_FP32);

        clk = 0;
        rst = 1;
        start = 0;
        mode_fp = 1'b0; 
        op_a = 32'd0;
        op_b = 32'd0;
        op_code = 2'b00;

        #20 rst = 0;


     

        op_a = 32'h7F800000; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40; 
        op_a = 32'hFF800000; op_b = 32'hBF800000; op_code = 2'b01; start = 1; #10; start = 0; #40;  
        op_a = 32'h7F800000; op_b = 32'hFF800000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h3F800000; op_b = 32'h00000000; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'h00000000; op_b = 32'h80000000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h00000000; op_b = 32'h80000000; op_code = 2'b01; start = 1; #10; start = 0; #40;  
        op_a = 32'h00000001; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40; 
        op_a = 32'h3F800000; op_b = 32'h00000001; op_code = 2'b11; start = 1; #10; start = 0; #100; 

        op_a = 32'h7FC00000; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'h3F800000; op_b = 32'h7FC00000; op_code = 2'b10; start = 1; #10; start = 0; #40; 
        op_a = 32'h7F800000; op_b = 32'h00000000; op_code = 2'b10; start = 1; #10; start = 0; #40;  

        op_a = 32'hBF800000; op_b = 32'h3F800000; op_code = 2'b00; start = 1; #10; start = 0; #40;  
        op_a = 32'hBF800000; op_b = 32'hBF800000; op_code = 2'b10; start = 1; #10; start = 0; #40;  
        op_a = 32'hBF800000; op_b = 32'h40000000; op_code = 2'b11; start = 1; #10; start = 0; #100; 



        #100;
        $finish;
    end

endmodule
