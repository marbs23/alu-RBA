`timescale 1ns / 1ps


module clk_divider #(parameter DIV = 100_000_000)(
    input clk, rst,
    output reg slow_clk
);
    reg [31:0] counter = 0;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter >= DIV) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule



module clk_display(
    input slow_clk,
    output reg [6:0] seg,
    output reg [3:0] an
);
    always @(*) begin
        an = 4'b1110;
        if (slow_clk)
            seg = 7'b1111001; // “1”
        else
            seg = 7'b0000001; // “0”
    end
endmodule

module state_display(
    input [2:0] state,
    output reg [6:0] seg,
    output reg [3:0] an
);
    always @(*) begin
        an = 4'b1101;
        case (state)
            3'd0: seg = 7'b0000001; 
            3'd1: seg = 7'b1001111; 
            3'd2: seg = 7'b0010010; 
            3'd3: seg = 7'b0000110; 
            3'd4: seg = 7'b1001100; 
            3'd5: seg = 7'b0100100; 
            3'd6: seg = 7'b0100000; 
            default: seg = 7'b1111111;
        endcase
    end
endmodule



module control_FSM(
    input clk, rst, btnC, btnR, valid_out,
    output reg [2:0] state,
    output reg start
);
    localparam S0=3'd0, S1=3'd1, S2=3'd2, S3=3'd3, S4=3'd4, S5=3'd5, S6=3'd6;
    reg [2:0] next_state;

    always @(posedge clk or posedge rst)
        if (rst) state <= S0;
        else     state <= next_state;

    always @(*) begin
        next_state = state;
        case (state)
            S0: if (btnC) next_state = S1;
            S1: if (btnC) next_state = S2;
            S2: if (btnC) next_state = S3;
            S3: if (btnC) next_state = S4;
            S4: if (btnC) next_state = S5;
            S5: if (valid_out) next_state = S6;
            S6: if (btnR) next_state = S0;
        endcase
    end

    always @(*) begin
        start = (state == S4 && btnC);
    end
endmodule


module top_FP_ALU_Basys3(
    input clk,
    input btnR,
    input [15:0] sw,
    input btnC,
    input btnU,
    output [15:0] led,
    output [6:0] seg,
    output [3:0] an
);
    wire slow_clk;
    clk_divider #(100_000_000) div(clk, btnR, slow_clk);

    wire [2:0] state;
    wire start, valid_out;

    reg [31:0] op_a, op_b;
    reg [1:0] op_code;
    reg mode_fp;
    wire [31:0] result;
    wire [4:0] flags;

    control_FSM fsm(
        .clk(slow_clk),
        .rst(btnR),
        .btnC(btnC),
        .btnR(btnR),
        .valid_out(valid_out),
        .state(state),
        .start(start)
    );

    wire [6:0] seg_clk, seg_state;
    wire [3:0] an_clk, an_state;

    clk_display clkdisp(.slow_clk(slow_clk), .seg(seg_clk), .an(an_clk));
    state_display statedisp(.state(state), .seg(seg_state), .an(an_state));

    assign seg = seg_clk & seg_state; // ambos encienden distintos dígitos
    assign an  = an_clk & an_state;   // mezcla para activar ambos displays

    always @(posedge slow_clk or posedge btnR) begin
        if (btnR) begin
            op_a <= 0; op_b <= 0; op_code <= 0; mode_fp <= 0;
        end else begin
            case (state)
                3'd0: if (btnC) mode_fp <= sw[15];
                3'd1: if (btnC) op_a[15:0]  <= sw;
                3'd2: if (btnC) op_a[31:16] <= sw;
                3'd3: if (btnC) op_b[15:0]  <= sw;
                3'd4: if (btnC) op_b[31:16] <= sw;
                3'd5: if (btnC) op_code     <= sw[1:0];
            endcase
        end
    end

    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(slow_clk),
        .rst(btnR),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    reg btnU_sync0, btnU_sync1, show_flags;
    always @(posedge slow_clk or posedge btnR) begin
        if (btnR) begin
            btnU_sync0 <= 0; btnU_sync1 <= 0; show_flags <= 0;
        end else begin
            btnU_sync0 <= btnU;
            btnU_sync1 <= btnU_sync0;
            if (btnU_sync0 & ~btnU_sync1)
                show_flags <= ~show_flags;
        end
    end

    assign led = (show_flags) ? {11'b0, flags} : result[15:0];
endmodule
