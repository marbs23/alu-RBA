`timescale 1ns/1ns


module FP_ALU_if16bits (
    input  [15:0] op_a, op_b,  
    input  [1:0]  op_code,  
    output reg [15:0] result,
    output reg [4:0]  flags
);
    // Decompose operands
    reg sign_a, sign_b, sign_res;
    reg [4:0] exp_a, exp_b, exp_res;
    reg [10:0] mant_a, mant_b;
    reg [11:0] mant_result;
    reg [4:0] exp_diff;
    reg carry;
    reg [21:0] mant_result_temp;
    reg [21:0] mant_result_temp_div;
    integer i;
    reg flag_overflow;   
    reg flag_underflow;  
    reg flag_divzero;    
    reg flag_invalid;  
    reg flag_inexact;

    always @(*) begin
        // 1. Decompose inputs
        sign_a = op_a[15];
        sign_b = op_b[15];
        exp_a  = op_a[14:10];
        exp_b  = op_b[14:10];
        mant_a = {1'b1, op_a[9:0]};
        mant_b = {1'b1, op_b[9:0]};

        // 2. Defaults
        sign_res = 0;
        exp_res  = 0;
        mant_result = 0;
        carry    = 0;
        flag_overflow  = 0;
        flag_underflow = 0;
        flag_divzero   = 0;
        flag_invalid   = 0;
        flag_inexact   = 0;
        
        // 3. Decode operation
        case (op_code)
            2'b00: // Suma
            begin 
                if (exp_b > exp_a) begin
                    exp_diff = exp_b - exp_a;
                    mant_a = mant_a >> exp_diff;
                    exp_res = exp_b;
                end else if (exp_a > exp_b) begin
                    exp_diff = exp_a - exp_b;
                    mant_b = mant_b >> exp_diff;
                    exp_res = exp_a;
                end else begin
                    exp_res = exp_a;
                end

                if (sign_a == sign_b) begin
                    mant_result = mant_a + mant_b;
                    sign_res = sign_a; // tienen el mismo signo
                end else begin
                    if (sign_a == 1'b0) begin // A positivo, B negativo
                        if (mant_a >= mant_b) begin
                            mant_result = mant_a - mant_b;
                            sign_res = 1'b0; // A positivo
                        end else begin
                            mant_result = mant_b - mant_a;
                            sign_res = 1'b1; // B negativo
                        end
                    end else begin // A negativo, B positivo
                        if (mant_a > mant_b) begin
                            mant_result = mant_a - mant_b;
                            sign_res = 1'b1; // A negativo
                        end else if (mant_b > mant_a) begin
                            mant_result = mant_b - mant_a;
                            sign_res = 1'b0; // B positivo
                        end 
                        else begin
                            mant_result = 0;
                            sign_res = 1'b0; // Resultado cero
                        end
                    end
                end
                    
                if (mant_result[11] == 1'b1) begin
                // Overflow → desplazamos hacia la derecha 1 vez
                mant_result = mant_result >> 1;
                exp_res = exp_res + 1;
                end else begin
                // Underflow → desplazamos hasta que MSB sea 1
                for (i = 0; i < 11; i = i + 1) 
                begin
                    if (mant_result[10] == 1'b1 || exp_res == 0)

                        i = 11; // Salir del bucle
                    else 
                    begin
                        mant_result = mant_result << 1;
                        exp_res = exp_res - 1;
                    end
                end
            end

            end
            2'b01: // Resta
            begin
                if (exp_b > exp_a) begin
                    exp_diff = exp_b - exp_a;
                    mant_a = mant_a >> exp_diff;
                    exp_res = exp_b;
                end else if (exp_a > exp_b) begin
                    exp_diff = exp_a - exp_b;
                    mant_b = mant_b >> exp_diff;
                    exp_res = exp_a;
                end else begin
                    exp_res = exp_a;
                end
                if (sign_a == sign_b) begin
                    if (sign_a == 1'b0) begin // A positivo, B positivo
                        if (mant_a >= mant_b) begin
                            mant_result = mant_a - mant_b;
                            sign_res = 1'b0; // A positivo
                        end else begin
                            mant_result = mant_b - mant_a;
                            sign_res = 1'b1; // B negativo
                        end
                    end else begin // A negativo, B negativo
                        if (mant_a > mant_b) begin
                            mant_result = mant_a + mant_b;
                            sign_res = 1'b1; // A negativo
                        end else if (mant_a < mant_b) begin
                            mant_result = mant_b - mant_b;
                            sign_res = 1'b0; // B positivo
                        end else begin
                            mant_result = 0;
                            sign_res = 1'b0; // Resultado cero
                        end
                    end
                end 
                for (i = 0; i < 11; i = i + 1) 
                begin
                    if (mant_result[10] == 1'b1 || exp_res == 0)

                        i = 11; // Salir del bucle
                    else 
                    begin
                        mant_result = mant_result << 1;
                        exp_res = exp_res - 1;
                    end
                end
            end    

            2'b10: 
            begin

                sign_res = sign_a ^ sign_b; // Result sign

                exp_res = exp_a + exp_b - 15; 


                mant_result_temp = mant_a * mant_b; // normalize

                if (mant_result_temp[21]) begin
                    mant_result_temp = mant_result_temp >> 1;
                    exp_res = exp_res + 1;
                end else begin
                    // Si el resultado está desnormalizado (bit 20 = 0)
                    for (i = 0; i < 10; i = i + 1) begin
                        if (mant_result_temp[20] == 1'b1 || exp_res == 0)
                            i = 10;
                        else begin
                            mant_result_temp = mant_result_temp << 1;
                            exp_res = exp_res - 1;
                        end

                    end
                end


                mant_result = mant_result_temp[20:10]; // Obtener los 11 bits más significativos
            end

            2'b11: 
            begin
            sign_res = sign_a ^ sign_b;
            exp_res  = exp_a - exp_b + 15;
    
            // Casos especiales
            if (op_b[14:0] == 15'b0) begin // divisor = 0
                flag_divzero = 1;
                result = {sign_res, 5'b11111, 10'b0}; // ±Inf
            end
            else if (op_a[14:0] == 15'b0 && op_b[14:0] == 15'b0) begin
                flag_invalid = 1;
                result = {1'b0, 5'b11111, 10'b1}; // NaN
            end
            else begin
                mant_result_temp_div = (mant_a << 11) / mant_b;
    
                if (mant_result_temp_div[21]) begin
                    mant_result_temp_div = mant_result_temp_div >> 1;
                    exp_res = exp_res + 1;
                end else begin
                    for (i = 0; i < 10; i = i + 1) begin
                        if (mant_result_temp_div[20] == 1'b1 || exp_res == 0)
                            i = 10;
                        else begin
                            mant_result_temp_div = mant_result_temp_div << 1;
                            exp_res = exp_res - 1;
                        end
                    end
                end
    
                mant_result = mant_result_temp_div[20:10];
                end
            end

        default: begin
                sign_res = 0;
                exp_res  = 0;
                mant_result = 0;
            end
        endcase

        result = {sign_res, exp_res[4:0], mant_result[9:0]};
    end
endmodule
