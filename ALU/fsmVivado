module clock_divider #(parameter DIVISOR = 25000000)(
    input clk,
    input rst,
    output reg slow_clk
);
    reg [31:0] counter;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter >= (DIVISOR - 1)) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule

module fsm_control(
    input clk,
    input rst,
    input next_btn,           // botón para avanzar estados
    input [3:0] sw_bits,      // 4 bits que entran por los switches
    input [1:0] op_sw,        // switches para op_code (00,01,10,11)
    output reg [31:0] op_a,
    output reg [31:0] op_b,
    output reg [1:0] op_code,
    output reg start,
    output reg [2:0] state
);

    // --- Estados ---
    parameter S0_IDLE    = 3'b000;
    parameter S1_LOAD_A  = 3'b001;
    parameter S2_LOAD_B  = 3'b010;
    parameter S3_LOAD_OP = 3'b011;
    parameter S4_EXECUTE = 3'b100;
    parameter S5_DONE    = 3'b101;

    reg [4:0] nibble_index;  // índice del bloque actual (32/4 = 8 pasos)
    reg [2:0] next_state;

    // --- Registro de estado ---
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= S0_IDLE;
            op_a <= 0;
            op_b <= 0;
            op_code <= 0;
            start <= 0;
            nibble_index <= 0;
        end else begin
            state <= next_state;
        end
    end

    // --- Lógica de transición de estados ---
    always @(*) begin
        next_state = state;
        start = 0;

        case (state)
            S0_IDLE:    if (next_btn) next_state = S1_LOAD_A;
            S1_LOAD_A:  if (next_btn && nibble_index == 7) next_state = S2_LOAD_B;
            S2_LOAD_B:  if (next_btn && nibble_index == 7) next_state = S3_LOAD_OP;
            S3_LOAD_OP: if (next_btn) next_state = S4_EXECUTE;
            S4_EXECUTE: next_state = S5_DONE;
            S5_DONE:    if (next_btn) next_state = S0_IDLE;
            default:    next_state = S0_IDLE;
        endcase
    end

    // --- Lógica de carga de datos y señales ---
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            op_a <= 0;
            op_b <= 0;
            nibble_index <= 0;
        end else begin
            case (state)
                S1_LOAD_A: begin
                    if (next_btn && nibble_index < 8) begin
                        op_a[(nibble_index*4)+3 -: 4] <= sw_bits;
                        nibble_index <= nibble_index + 1;
                    end
                end
                S2_LOAD_B: begin
                    if (next_btn && nibble_index < 8) begin
                        op_b[(nibble_index*4)+3 -: 4] <= sw_bits;
                        nibble_index <= nibble_index + 1;
                    end
                end
                S3_LOAD_OP: begin
                    op_code <= op_sw;
                    nibble_index <= 0;
                end
                S4_EXECUTE: begin
                    start <= 1;
                end
                default: nibble_index <= 0;
            endcase
        end
    end
endmodule


module top_fp_alu_fsm(
    input clk,
    input rst,
    input next_btn,          // botón para avanzar FSM
    input [3:0] sw_bits,     // switches para ingresar 4 bits
    input [1:0] op_switches, // switches para operación
    output [15:0] leds
);
    wire slow_clk;
    wire [31:0] op_a, op_b, result;
    wire [1:0]  op_code;
    wire [4:0]  flags;
    wire        start, valid_out;
    wire [2:0]  state;

    // Clock divisor
    clock_divider #(25000000) div(
        .clk(clk),
        .rst(rst),
        .slow_clk(slow_clk)
    );

    // FSM de control
    fsm_control fsm(
        .clk(slow_clk),
        .rst(rst),
        .next_btn(next_btn),
        .sw_bits(sw_bits),
        .op_sw(op_switches),
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .start(start),
        .state(state)
    );

    // ALU de punto flotante (tu módulo)
    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(clk),
        .rst(rst),
        .start(start),
        .mode_fp(1'b1),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    // LEDs: resultado + estado + flags
    assign leds[7:0]   = result[7:0];
    assign leds[10:8]  = state;
    assign leds[15:11] = flags;
endmodule

## Clock 100 MHz
set_property PACKAGE_PIN W5 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports clk]

## Reset Button (BTNC)
set_property PACKAGE_PIN T18 [get_ports rst]
set_property IOSTANDARD LVCMOS33 [get_ports rst]

## Next Button (BTNR)
set_property PACKAGE_PIN U17 [get_ports next_btn]
set_property IOSTANDARD LVCMOS33 [get_ports next_btn]

## Switches (SW0–SW3) -> 4 bits de entrada
set_property PACKAGE_PIN V17 [get_ports {sw_bits[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw_bits[0]}]
set_property PACKAGE_PIN V16 [get_ports {sw_bits[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw_bits[1]}]
set_property PACKAGE_PIN W16 [get_ports {sw_bits[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw_bits[2]}]
set_property PACKAGE_PIN W17 [get_ports {sw_bits[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw_bits[3]}]

## Operation switches (SW4–SW5)
set_property PACKAGE_PIN W15 [get_ports {op_switches[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {op_switches[0]}]
set_property PACKAGE_PIN V15 [get_ports {op_switches[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {op_switches[1]}]

## LEDs [0–15]
set_property PACKAGE_PIN H17 [get_ports {leds[0]}]
set_property PACKAGE_PIN K15 [get_ports {leds[1]}]
set_property PACKAGE_PIN J13 [get_ports {leds[2]}]
set_property PACKAGE_PIN N14 [get_ports {leds[3]}]
set_property PACKAGE_PIN R12 [get_ports {leds[4]}]
set_property PACKAGE_PIN P12 [get_ports {leds[5]}]
set_property PACKAGE_PIN P11 [get_ports {leds[6]}]
set_property PACKAGE_PIN N11 [get_ports {leds[7]}]
set_property PACKAGE_PIN L14 [get_ports {leds[8]}]
set_property PACKAGE_PIN M13 [get_ports {leds[9]}]
set_property PACKAGE_PIN L13 [get_ports {leds[10]}]
set_property PACKAGE_PIN N15 [get_ports {leds[11]}]
set_property PACKAGE_PIN P15 [get_ports {leds[12]}]
set_property PACKAGE_PIN R16 [get_ports {leds[13]}]
set_property PACKAGE_PIN R15 [get_ports {leds[14]}]
set_property PACKAGE_PIN P14 [get_ports {leds[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {leds[*]}]
