`timescale 1ns/1ps

module FP_ALU_if16bits (
    input  [15:0] op_a, op_b,
    input  [1:0]  op_code,
    output reg [15:0] result
);

    // IEEE 754 half precision constants
    localparam BIAS = 5'd15;

    // Internal registers
    reg sign_a, sign_b, sign_res;
    reg [4:0] exp_a, exp_b, exp_res;
    reg [10:0] mant_a, mant_b;
    reg [21:0] mant_prod;
    reg [10:0] mant_res;
    reg [4:0] exp_diff;

    always @(*) begin
        // --- Decompose inputs ---
        sign_a = op_a[15];
        sign_b = op_b[15];
        exp_a  = op_a[14:10];
        exp_b  = op_b[14:10];
        mant_a = (exp_a == 0) ? {1'b0, op_a[9:0]} : {1'b1, op_a[9:0]};
        mant_b = (exp_b == 0) ? {1'b0, op_b[9:0]} : {1'b1, op_b[9:0]};

        // --- Defaults ---
        exp_res = 0;
        mant_res = 0;
        sign_res = 0;

        case (op_code)

        // =========================
        // ADD / SUB
        // =========================
        2'b00, 2'b01: begin
            // Resta = invertir signo de B
            if (op_code == 2'b01)
                sign_b = ~sign_b;

            // Alinear exponentes
            if (exp_a > exp_b) begin
                exp_diff = exp_a - exp_b;
                mant_b = mant_b >> exp_diff;
                exp_res = exp_a;
            end else if (exp_b > exp_a) begin
                exp_diff = exp_b - exp_a;
                mant_a = mant_a >> exp_diff;
                exp_res = exp_b;
            end else begin
                exp_res = exp_a;
            end

            // Operación según signo
            if (sign_a == sign_b) begin
                mant_res = mant_a + mant_b;
                sign_res = sign_a;
            end else begin
                if (mant_a >= mant_b) begin
                    mant_res = mant_a - mant_b;
                    sign_res = sign_a;
                end else begin
                    mant_res = mant_b - mant_a;
                    sign_res = sign_b;
                end
            end

            // Normalizar (chequear overflow o underflow)
            if (mant_res[10]) begin
                mant_res = mant_res >> 1;
                exp_res = exp_res + 1;
            end else begin
                while (mant_res[9] == 0 && exp_res > 0) begin
                    mant_res = mant_res << 1;
                    exp_res = exp_res - 1;
                end
            end
        end

        // =========================
        // MULTIPLICACIÓN
        // =========================
        2'b10: begin
            sign_res = sign_a ^ sign_b;
            mant_prod = mant_a * mant_b; // 11x11 = 22 bits
            exp_res = exp_a + exp_b - BIAS;

            // Normalización
            if (mant_prod[21]) begin
                mant_res = mant_prod[21:11];
                exp_res = exp_res + 1;
            end else begin
                mant_res = mant_prod[20:10];
            end
        end

        // =========================
        // DIVISIÓN
        // =========================
        2'b11: begin
            sign_res = sign_a ^ sign_b;
            exp_res = exp_a - exp_b + BIAS;

            // Escalar antes de dividir para conservar precisión
            mant_prod = (mant_a << 10) / mant_b;

            if (mant_prod[10]) begin
                mant_res = mant_prod[10:0];
            end else begin
                mant_res = mant_prod[9:0] << 1;
                exp_res = exp_res - 1;
            end
        end

        default: begin
            exp_res = 0;
            mant_res = 0;
            sign_res = 0;
        end
        endcase

        // Empaquetar resultado
        result = {sign_res, exp_res[4:0], mant_res[9:0]};
    end
endmodule




`timescale 1ns / 1ps

module tb_FP_ALU_if16bits;

    // Entradas
    reg  [15:0] op_a, op_b;
    reg  [1:0]  op_code;

    // Salida
    wire [15:0] result;

    // Instancia del DUT (Device Under Test)
    FP_ALU_if16bits dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .result(result)
    );

    // Tarea para imprimir resultados
    task show_result;
        input [1:0] op_code;
        input [15:0] a;
        input [15:0] b;
        begin
            $display("------------------------------------------------");
            case (op_code)
                2'b00: $display("Operacion: SUMA");
                2'b01: $display("Operacion: RESTA");
                2'b10: $display("Operacion: MULTIPLICACION");
                2'b11: $display("Operacion: DIVISION");
            endcase
            $display("op_a = %h, op_b = %h", a, b);
            $display("Resultado (16 bits IEEE754) = %h", result);
            $display(" Signo=%b  Exp=%b  Mantisa=%b", 
                     result[15], result[14:10], result[9:0]);
            $display("------------------------------------------------\n");
        end
    endtask

    initial begin
        $dumpfile("FP_ALU_if16bits_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if16bits);

        // ------------------------------------------------
        // Half precision ejemplos (IEEE-754 binary16):
        // 1.0  = 0x3C00
        // 2.0  = 0x4000
        // 3.0  = 0x4200
        // 4.0  = 0x4400
        // 8.0  = 0x4800
        // ------------------------------------------------

        // Test 1: 1.0 + 2.0 = 3.0
        op_a = 16'h3C00;  // 1.0
        op_b = 16'h4000;  // 2.0
        op_code = 2'b00;  // Suma
        #10;
        show_result(op_code, op_a, op_b);

        // Test 2: 3.0 - 1.0 = 2.0
        op_a = 16'h4200;  // 3.0
        op_b = 16'h3C00;  // 1.0
        op_code = 2'b01;  // Resta
        #10;
        show_result(op_code, op_a, op_b);

        // Test 3: 2.0 × 4.0 = 8.0
        op_a = 16'h4000;  // 2.0
        op_b = 16'h4400;  // 4.0
        op_code = 2'b10;  // Multiplicación
        #10;
        show_result(op_code, op_a, op_b);

        // Test 4: 8.0 ÷ 2.0 = 4.0
        op_a = 16'h4800;  // 8.0
        op_b = 16'h4000;  // 2.0
        op_code = 2'b11;  // División
        #10;
        show_result(op_code, op_a, op_b);

        // Test 5: 1.5 + 2.5 = 4.0
        op_a = 16'h3E00;  // 1.5
        op_b = 16'h4200;  // 2.5
        op_code = 2'b00;
        #10;
        show_result(op_code, op_a, op_b);

        $display("Simulacion completada exitosamente.");
        $finish;
    end

endmodule

`timescale 1ns/1ps

module tb_FP_ALU_if16bits;

    // -------------------------------
    // Entradas
    // -------------------------------
    reg [15:0] op_a;
    reg [15:0] op_b;
    reg [1:0]  op_code;

    // -------------------------------
    // Salidas
    // -------------------------------
    wire [15:0] result;

    // -------------------------------
    // Instancia del DUT
    // -------------------------------
    FP_ALU_if16bits dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .result(result)
    );

    // -------------------------------
    // Variables auxiliares
    // -------------------------------
    integer i;

    // -------------------------------
    // Tarea para imprimir resultados
    // -------------------------------
    task show_result;
        input [1:0] op_code;
        input [15:0] a;
        input [15:0] b;
        begin
            $display("------------------------------------------------");
            case (op_code)
                2'b00: $display("Operacion: SUMA");
                2'b01: $display("Operacion: RESTA");
                2'b10: $display("Operacion: MULTIPLICACION");
                2'b11: $display("Operacion: DIVISION");
            endcase
            $display("op_a = %h, op_b = %h", a, b);
            $display("Resultado = %h", result);
            $display(" Signo = %b, Exponente = %b, Mantisa = %b", 
                      result[15], result[14:10], result[9:0]);
            $display("------------------------------------------------\n");
        end
    endtask

    // -------------------------------
    // Secuencia de prueba
    // -------------------------------
    initial begin
        $dumpfile("fp_alu_if16bits_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if16bits);

        // --------------------------------------------
        // Ejemplos Half-Precision (IEEE 754 16 bits)
        // --------------------------------------------
        // 1.0  = 0x3C00
        // 2.0  = 0x4000
        // 3.0  = 0x4200
        // 4.0  = 0x4400
        // 8.0  = 0x4800
        // --------------------------------------------

        // ---- Test 1: 1.0 + 2.0 = 3.0 ----
        op_a = 16'h3C00;  // 1.0
        op_b = 16'h4000;  // 2.0
        op_code = 2'b00;  // SUMA
        #10;
        show_result(op_code, op_a, op_b);

        // ---- Test 2: 3.0 - 1.0 = 2.0 ----
        op_a = 16'h4200;  // 3.0
        op_b = 16'h3C00;  // 1.0
        op_code = 2'b01;  // RESTA
        #10;
        show_result(op_code, op_a, op_b);

        // ---- Test 3: 2.0 * 4.0 = 8.0 ----
        op_a = 16'h4000;  // 2.0
        op_b = 16'h4400;  // 4.0
        op_code = 2'b10;  // MULTIPLICACION
        #10;
        show_result(op_code, op_a, op_b);

        // ---- Test 4: 8.0 / 2.0 = 4.0 ----
        op_a = 16'h4800;  // 8.0
        op_b = 16'h4000;  // 2.0
        op_code = 2'b11;  // DIVISION
        #10;
        show_result(op_code, op_a, op_b);

        // ---- Test 5: 1.5 + 2.5 = 4.0 ----
        op_a = 16'h3E00;  // 1.5
        op_b = 16'h4200;  // 2.5
        op_code = 2'b00;  // SUMA
        #10;
        show_result(op_code, op_a, op_b);

        $display("Simulacion completada correctamente.");
        $finish;
    end

endmodule
