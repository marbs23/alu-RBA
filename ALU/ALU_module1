// Code your testbench here
// or browse Examples


module fp_alu (
    input  wire        clk, rst, start,
    input  wire [31:0] op_a, op_b,
    input  wire [2:0]  op_code,  
    input  wire        mode_fp,   // 0=FP16, 1=FP32
    input  wire [1:0]  round_mode,// 00 = RNE
    output reg  [31:0] result,    // si FP16, salida en 16 LSB
    output reg         valid_out,
    output reg  [4:0]  flags      // OVF,UDF,DIV0,INV,INX
);

  // IEEE parametros
localparam BIAS32 = 127, BIAS16 = 15;
localparam S_IDLE = 2'd0, S_EXEC = 2'd1, S_DONE = 2'd2;
reg [1:0] state;

// FP32 internal signals
  reg [31:0] A32, B32, R32_raw, R32; // R32_raw = resultado crudo, R32 = resultado post especial
reg [4:0]  F;

// Funciones IEEE - weird cases
  function is_nan32(input [31:0] x);    begin is_nan32  = (&x[30:23]) && (|x[22:0]); end endfunction //& de todos los bits, todos 1s, | or de todos los bits- si ambas condiciones se cumplen es nan
  function is_inf32(input [31:0] x);    begin is_inf32  = (&x[30:23]) && (~|x[22:0]); end endfunction// infinito cuanto todos los bits del exponente son 1 y todos los bits de mantisa 0
  function is_zero32(input [31:0] x);   begin is_zero32 = (x[30:0] == 31'b0); end endfunction //trivial..
function is_sub32(input [31:0] x);    begin is_sub32  = (x[30:23]==8'b0) && (|x[22:0]); end endfunction //numeros pequeños, exponente todos 0s y al menos un 1 en la mantisa

//conversion de 16 a 32 bits
function [31:0] fp16_to_fp32(input [15:0] h);
  reg s; reg [4:0] e; reg [9:0] m;// separar bits
  reg [7:0] E32; reg [22:0] M32;
    integer shift;// shift para ver cuantos bits se va a desplazar
begin
    s = h[15]; e = h[14:10]; m = h[9:0];

  if (e==5'b0) begin // caso exponente 0 
        if (m==10'b0) begin
            fp16_to_fp32 = {s,8'b0,23'b0}; // 0
        end else begin // numero subnormal
          shift = $clog2(m) ? (9 - $clog2(m)) : (9 - $clog2(m)); // robust shift calc ==++EwewfEWF+weoiewowfeowoiwe
            // Encuentra primer 1 desde MSB
            shift = 0;
            while (shift<10 && !m[9-shift]) shift = shift + 1;
            // Normaliza
          
            // En single: exp = 1 - BIAS16 + BIAS32 - shift
            E32 = (1 - BIAS16) + BIAS32 - shift;
          M32 = ((m << (shift+1)) & 10'h3FF) << (23-10);//conservar solo los 10 bits a la derecha
            fp16_to_fp32 = {s, E32, M32};
        end
    end else if (e==5'b11111) begin
        // Inf/NaN
        fp16_to_fp32 = {s,8'hFF,{m,13'b0}};
    end else begin
        // normal
        E32 = (e - BIAS16) + BIAS32;
        M32 = {m,13'b0};
        fp16_to_fp32 = {s,E32,M32};
    end
end
endfunction


  // RNE para FP32 -> FP16 (con G/R/S)...
  
function [15:0] pack_rne_fp16(
    input        s32,
    input  [7:0] e32,
    input [22:0] m32,
    output       ovf_cvt,
    output       udf_cvt,
    output       inx_cvt
);
    integer Ehalf;              // exponente real
    reg [24:0] mant_ext;        // 1.mantisa 
  reg [10:0] mant_rounded;    // post redondeo
    reg [12:0] tail;            // bits descartados
    reg guard, roundb, sticky;
    reg [4:0] Epack;
    reg ovf, udf, inx;
    reg [15:0] out;
begin
    ovf = 1'b0; udf = 1'b0; inx = 1'b0;

    // Casos especiales de entrada
    if (e32==8'hFF) begin
        // Inf o NaN
        if (m32==0) begin out = {s32,5'h1F,10'b0}; end
        else         begin out = {s32,5'h1F,10'h200}; end 
        ovf=1'b0; udf=1'b0; inx=1'b0;
        pack_rne_fp16 = out; ovf_cvt=ovf; udf_cvt=udf; inx_cvt=inx; return;
    end

  if (e32==8'h00) begin // 0 o subnormal

        if (m32==0) begin
            out = {s32,5'b0,10'b0}; // ±0
            pack_rne_fp16 = out; ovf_cvt=0; udf_cvt=0; inx_cvt=0; return;
          
          
        end
    end

    // Normalizar 1.m en single
  mant_ext = {1'b1, m32}; // (1 implicito + 23 mantisa)
    // Exponente convertirdo a FP16
    Ehalf = integer'(e32) - BIAS32 + BIAS16;

  if (Ehalf >= 31) begin// numero demaciado grande para 16 bits
        // Sol: saturar a infinito, sale un inexacto por saturacion
        out = {s32,5'h1F,10'b0}; // Inf
        ovf=1'b0; udf=1'b0; inx=1'b1; 
        pack_rne_fp16 = out; ovf_cvt=1'b1; udf_cvt=udf; inx_cvt=inx; return; // se marca el flag de overflow
    end
  
  
  
  

    if (Ehalf <= 0) begin
        // Resultado subnormal o cero
        // Shift para llevar el bit implicito al lugar subnormal
        // Queremos producir 0.mant, tomando 10 bits, con G/R/S
        // Posición del bit LSB de half = 13 bits por debajo de m32[22]
    
        integer shift_amt;
        reg [36:0] sh; 
      shift_amt = (1 - Ehalf); // cuantos pasos por debajo del monimo normal
      sh = {mant_ext,13'b0}; // 13 bits para el GRS
        if (shift_amt > 24+13) shift_amt = 24+13; // límite
        
        // Para subnormal, la mantisa target son los 10 bits más altos de (mant_ext >> (shift_amt)) posicionados en 10 MSBs
        reg [36:0] shifted;
        shifted = sh >> shift_amt;

        // Campo a tomar: bit [36 : 27] -> 10 bits (mantisa), luego vienen G,R,S
        reg [9:0]  mant10;
        mant10 = shifted[36:27];
        guard   = shifted[26];
        roundb  = shifted[25];
        sticky  = |shifted[24:0];

      mant_rounded = slice;

      
      // RNE (tie to even)
    inx = guard | roundb | sticky;
    if (guard && (roundb | sticky | slice[0])) begin
        mant_rounded = slice + 11'b1;
    end

    // Posible desborde de la mantisa (lleva a incrementar exponente)
    if (mant_rounded[10]) begin
        // Se mantiene 1.xxxxx normal
        Epack = Ehalf[4:0];
        // Si hubo carry que empujó a 2.000... (improbable con 11 bits, pero por seguridad):
        if (mant_rounded[10] && (mant_rounded[9:0]==10'b0) && (slice==11'h7FF)) begin
            // carry a exponente
            if (Ehalf+1 >= 31) begin
                out = {s32,5'h1F,10'b0}; // Inf
                ovf=1'b1; udf=1'b0; // inexact ya en inx
                pack_rne_fp16 = out; ovf_cvt=ovf; udf_cvt=udf; inx_cvt=inx; return;
            end else begin
                Epack = (Ehalf+1)[4:0];
            end
        end
        out = {s32,Epack,mant_rounded[9:0]};
    end else begin
        // Si por rounding se “perdió” el 1 (no debería en RNE normal), protegemos:
        out = {s32,Ehalf[4:0],mant_rounded[9:0]};
    end

    ovf_cvt = 1'b0; udf_cvt = 1'b0; inx_cvt = inx;
    pack_rne_fp16 = out;
end
endfunction


// FP32 -> FP16 con RNE + flags de conversión

function [15:0] fp32_to_fp16_rne(
    input [31:0] f,
    output       ovf_c, output udf_c, output inx_c
);
    reg s; reg [7:0] e; reg [22:0] m;
begin
    s = f[31]; e = f[30:23]; m = f[22:0];

    if (e==8'h00 && m==0) begin
        fp32_to_fp16_rne = {s,5'b0,10'b0};
        ovf_c=0; udf_c=0; inx_c=0; return;
    end
    fp32_to_fp16_rne = pack_rne_fp16(s,e,m, ovf_c,udf_c,inx_c);
end
endfunction

  //Basic operations :)
  
always @(*) begin
    // Conversión de entrada segun modo
    if (mode_fp) begin
        A32 = op_a;
        B32 = op_b;
    end else begin
        A32 = fp16_to_fp32(op_a[15:0]);
        B32 = fp16_to_fp32(op_b[15:0]);
    end

    R32_raw = 32'b0;
    R32     = 32'b0;
    F       = 5'b0;

    // Validacion de round_mode (solo RNE=2'b00 soportado)
    if (round_mode != 2'b00) F[1] = 1'b1; // INV

    // Casos especiales antes de operar
    // NaN domina: si cualquiera es NaN -> NaN
    if (is_nan32(A32) || is_nan32(B32)) begin
        R32 = {1'b0,8'hFF,23'h400000}; // quiet NaN canonical
        F[1] = 1'b1; // invalid operation al menos conservador
    end else begin
        case (op_code)
            3'b000: begin // ADD
                // ±Inf + (finito) = ±Inf ; Inf + (-Inf) = NaN
                if (is_inf32(A32) && is_inf32(B32) && (A32[31]^B32[31])) begin
                    R32 = {1'b0,8'hFF,23'h400000}; // NaN
                    F[1]=1'b1; // INV
                end else if (is_inf32(A32)) begin
                    R32 = A32;
                end else if (is_inf32(B32)) begin
                    R32 = B32;
                end else begin
                    R32_raw = A32 + B32;
                    R32 = R32_raw;
                end
            end
            3'b001: begin // SUB
                if (is_inf32(A32) && is_inf32(B32) && ~(A32[31]^B32[31])) begin
                    // +Inf - +Inf o -Inf - -Inf => NaN
                    R32 = {1'b0,8'hFF,23'h400000}; F[1]=1'b1;
                end else if (is_inf32(A32)) begin
                    R32 = A32;
                end else if (is_inf32(B32)) begin
                    R32 = {~B32[31],8'hFF,23'b0}; // -(signo de B) * Inf
                end else begin
                    R32_raw = A32 - B32;
                    R32 = R32_raw;
                end
            end
            3'b010: begin // MUL
                // 0 * Inf = NaN
                if ((is_zero32(A32) && is_inf32(B32)) || (is_zero32(B32) && is_inf32(A32))) begin
                    R32 = {1'b0,8'hFF,23'h400000}; F[1]=1'b1; // INV
                end else if (is_inf32(A32) || is_inf32(B32)) begin
                    // signo = XOR signos
                    R32 = {A32[31]^B32[31],8'hFF,23'b0};
                end else begin
                    R32_raw = A32 * B32;
                    R32 = R32_raw;
                end
            end
            3'b011: begin // DIV
                // 0/0, Inf/Inf => NaN (INV)
                if ((is_zero32(A32) && is_zero32(B32)) || (is_inf32(A32) && is_inf32(B32))) begin
                    R32 = {1'b0,8'hFF,23'h400000}; F[1]=1'b1; // INV
                end else if (is_inf32(A32) && ~is_inf32(B32)) begin
                    R32 = {A32[31]^B32[31],8'hFF,23'b0}; // Inf con signo
                end else if (~is_inf32(A32) && is_inf32(B32)) begin
                    R32 = {A32[31]^B32[31],8'b0,23'b0};  // 0 con signo
                end else if (is_zero32(B32)) begin
                    // div/0 => Inf con signo, DIV0 flag
                    R32 = {A32[31]^B32[31],8'hFF,23'b0};
                    F[2]=1'b1; // DIV0
                end else begin
                    R32_raw = A32 / B32;
                    R32 = R32_raw;
                end
            end
            default: begin
                R32 = 32'b0;
            end
        endcase
    end

    // Flags de overflow/underflow aproximados en SINGLE:
    //   OVF si exponente resultante = 255 y mantisa=0 (Inf) o NaN ya cubierto.
    //   UDF si resultado es subnormal o cero por magnitud muy pequeña.
    if (is_inf32(R32) && !is_nan32(R32)) F[4]=1'b1; // OVF
    if (is_sub32(R32))                   F[3]=1'b1; // UDF (subnormal)
    if (is_zero32(R32) && ~is_zero32(A32) && ~is_zero32(B32)) F[3]=1'b1; // tiny to zero

    // INX (inexact) lo deducimos al convertir a half (o al detectar G/R/S).
    // Para FP32 puro (mode_fp=1) no redondeamos de precisión, así que dejamos INX como está (0 por defecto)
    // y lo ajustamos en la fase de empaquetado cuando mode_fp=0.
end

// FSM de control (start / valid_out) y empaquetado de salida
always @(posedge clk or posedge rst) begin
    if (rst) begin
        state     <= S_IDLE;
        result    <= 0;
        valid_out <= 0;
        flags     <= 0;
    end else begin
        case (state)
            S_IDLE: begin
                valid_out <= 0;
                if (start) state <= S_EXEC;
            end
            S_EXEC: begin
                // Empaquetado de salida según modo y cálculo de INX/OVF/UDF por conversión
                if (mode_fp) begin
                    // Modo FP32: salida directa
                    result <= R32;
                    flags  <= F; // INX podría ser 1 si hubo INV/DIV0/…; no hay redondeo de precisión aquí
                end else begin
                    // Modo FP16: convertir con RNE y propagar flags por conversión
                    reg ovf_c, udf_c, inx_c;
                    reg [15:0] halfp;
                    halfp = fp32_to_fp16_rne(R32, ovf_c, udf_c, inx_c);
                    result <= {16'b0, halfp};

                    flags       <= F;
                    flags[4]    <= F[4] | ovf_c; // OVF
                    flags[3]    <= F[3] | udf_c; // UDF
                    flags[0]    <= F[0] | inx_c; // INX
                end
                valid_out <= 1;
                state <= S_DONE;
            end
            S_DONE: begin
                valid_out <= 0;
                state <= S_IDLE;
            end
        endcase
    end
end

endmodule
