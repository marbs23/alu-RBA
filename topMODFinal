Código completo:

// =====================================================
// 1. Divisor de reloj (2 segundos aprox)
// =====================================================
module clk_divider #(parameter DIV = 100_000_000)( // 2 s a 100 MHz
    input clk, rst,
    output reg slow_clk
);
    reg [31:0] counter = 0;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter >= DIV) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule


// =====================================================
// 2. Display para mostrar el estado del clock
// =====================================================
module clk_display(
    input slow_clk,
    output reg [6:0] seg,  // segmentos (a-g)
    output reg [3:0] an    // ánodos del display
);
    always @(*) begin
        an = 4'b1110; // usar solo el dígito más a la derecha
        if (slow_clk)
            seg = 7'b1111001; // "1"
        else
            seg = 7'b0000001; // "0"
    end
endmodule


// =====================================================
// 3. FSM de control
// =====================================================
module control_FSM(
    input clk, rst, btnC, btnR, valid_out,
    output reg [3:0] state,
    output reg start
);
    localparam S0=4'd0, S1=4'd1, S2=4'd2, S3=4'd3, S4=4'd4,
               S5=4'd5, S6=4'd6, S7=4'd7, S8=4'd8;
    reg [3:0] next_state;

    always @(posedge clk or posedge rst)
        if (rst) state <= S0;
        else     state <= next_state;

    always @(*) begin
        next_state = state;
        case (state)
            S0: if (btnC) next_state = S1;
            S1: if (btnC) next_state = S2;
            S2: if (btnC) next_state = S3;
            S3: if (btnC) next_state = S4;
            S4: if (btnC) next_state = S5;   // <--- nuevo paso para seleccionar op_code
            S5: if (btnC) next_state = S6;   // ahora recién pasamos a mostrar resultados
            S6: if (btnC) next_state = S7;
            S7: if (btnC) next_state = S8;
            S8: if (btnR) next_state = S0;
        endcase
    end

    always @(*) begin
        start = (state == S5 && btnC);  // <--- ahora start ocurre después de seleccionar operación
    end
endmodule



// =====================================================
// 4. Top principal (Basys3)
// =====================================================
module top_FP_ALU_Basys3(
    input clk,
    input btnR,          // reset global
    input [15:0] sw,     // switches de entrada
    input btnC,          // confirmar / avanzar FSM
    input btnU, 
    input btnL,           // mostrar flags
    output reg [15:0] led,   // LEDs: resultado o flags
    output [6:0] seg,    // display 7 segmentos
    output [3:0] an      // control de ánodos
);
    // Clock lento (~2 s)
    wire slow_clk;
    clk_divider #(100_000_000) div(clk, btnR, slow_clk);

    // FSM
    wire [3:0] state;
    wire start, valid_out;

    reg [31:0] op_a, op_b;
    reg [1:0] op_code;
    reg mode_fp; // 0=FP32, 1=FP16
    wire [31:0] result;
    wire [4:0] flags;

    // FSM de control
    control_FSM fsm(
        .clk(slow_clk),
        .rst(btnR),
        .btnC(btnC),
        .btnR(btnR),
        .valid_out(valid_out),
        .state(state),
        .start(start)
    );

    // ======== Display del clock ========
    clk_display disp(.slow_clk(slow_clk), .seg(seg), .an(an));

    // ======== Entrada de datos ========
    //wire state_led;
    //assign state_led = state;
    always @(posedge slow_clk or posedge btnR) begin
    if (btnR) begin
        op_a <= 0; op_b <= 0; op_code <= 0; mode_fp <= 0;
    end else begin
        case (state)
            4'd0: begin
                led <= state;
                if (btnL) begin
                    mode_fp <= sw[15]; // selecciona modo
                    led <= 4'd7;
                end
            end

            4'd1: begin
                led <= state;
                if (btnL) begin
                    op_a[15:0] <= sw;
                    led <= 4'd7;
                end
            end

            4'd2: begin
                led <= state;
                if (btnL) begin
                    op_a[31:16] <= sw;
                    led <= 4'd7;
                end
            end

            4'd3: begin
                led <= state;
                if (btnL) begin
                    op_b[15:0] <= sw;
                    led <= 4'd7;
                end
            end

            4'd4: begin
                led <= state;
                if (btnL) begin
                    op_b[31:16] <= sw;
                    led <= 4'd7;
                end
            end

            // === NUEVO ESTADO ===
            4'd5: begin
                led <= 16'h00F0; // Indicar selección de operación
                if (btnL) begin
                    op_code <= sw[1:0]; // 00=add,01=sub,10=mul,11=div
                    led <= 16'h0F00;    // feedback visual
                end
            end

            4'd6: led <= result[15:0];
            4'd7: led <= result[31:16];
            4'd8: led <= flags;
        endcase
    end
end


    // ======== ALU ========
    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(slow_clk),
        .rst(btnR),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    // ======== Botón para mostrar flags ========
    reg btnU_sync0, btnU_sync1, show_flags;
    always @(posedge slow_clk or posedge btnR) begin
        if (btnR) begin
            btnU_sync0 <= 0; btnU_sync1 <= 0; show_flags <= 0;
        end else begin
            btnU_sync0 <= btnU;
            btnU_sync1 <= btnU_sync0;
            if (btnU_sync0 & ~btnU_sync1)
                show_flags <= ~show_flags;
        end
    end

    // ======== Salida a LEDs ========
    //assign led = (show_flags) ? {11'b0, flags} : result[15:0];
endmodule



module FP_ALU_if (
    input  [31:0] op_a, op_b,
    input  [1:0]  op_code,        
    input         clk, rst,
    input         start,
    input         mode_fp,        
    output reg [31:0] result,
    output reg [4:0]  flags,      
    output reg        valid_out
);

    wire [7:0] bias_sel     = mode_fp ? 8'd15  : 8'd127;
    wire [7:0] exp_max_sel  = mode_fp ? 8'd30  : 8'd254;
    wire [7:0] exp_min_sel  = 8'd1;

    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;
    reg [24:0] mant_sum;
    reg [7:0]  exp_diff;
    reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;
    reg [47:0] q, div_numer, remainder;
    reg [22:0] frac_div;
    reg [23:0] frac_round;
    reg guard_bit, sticky_bit, lsb_bit;
    reg round_inc, overflow, underflow;
    reg [47:0] product;
    reg [22:0] frac_mul;
    reg did_round;


    always @(*) begin
        result     = 32'b0;
        flags      = 5'b00000;
        valid_out  = 1'b0;

        if (mode_fp) begin
            sign_a = op_a[15];
            sign_b = op_b[15];
            exp_a  = {3'b000, op_a[14:10]};
            exp_b  = {3'b000, op_b[14:10]};
            mant_a = (exp_a[4:0]==5'd0) ? {1'b0, op_a[9:0], 13'b0} : {1'b1, op_a[9:0], 13'b0};
            mant_b = (exp_b[4:0]==5'd0) ? {1'b0, op_b[9:0], 13'b0} : {1'b1, op_b[9:0], 13'b0};

            a_is_nan  = (exp_a[4:0]==5'h1F) && (op_a[9:0]!=0);
            b_is_nan  = (exp_b[4:0]==5'h1F) && (op_b[9:0]!=0);
            a_is_inf  = (exp_a[4:0]==5'h1F) && (op_a[9:0]==0);
            b_is_inf  = (exp_b[4:0]==5'h1F) && (op_b[9:0]==0);
            a_is_zero = (exp_a[4:0]==5'd0)  && (op_a[9:0]==0);
            b_is_zero = (exp_b[4:0]==5'd0)  && (op_b[9:0]==0);
        end else begin
            sign_a = op_a[31];
            sign_b = op_b[31];
            exp_a  = op_a[30:23];
            exp_b  = op_b[30:23];
            mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
            mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

            a_is_nan  = (exp_a==8'hFF) && (op_a[22:0]!=0);
            b_is_nan  = (exp_b==8'hFF) && (op_b[22:0]!=0);
            a_is_inf  = (exp_a==8'hFF) && (op_a[22:0]==0);
            b_is_inf  = (exp_b==8'hFF) && (op_b[22:0]==0);
            a_is_zero = (exp_a==8'd0)  && (op_a[22:0]==0);
            b_is_zero = (exp_b==8'd0)  && (op_b[22:0]==0);
        end

        case (op_code)
 
        2'b00, 2'b01: begin

            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1; // invalid
            end else if (a_is_inf && b_is_inf && (sign_a != (op_code==2'b01 ? ~sign_b : sign_b))) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else begin
                if (op_code == 2'b01) sign_b = ~sign_b;

                if (exp_a > exp_b) begin
                    exp_diff = exp_a - exp_b;
                    mant_b = mant_b >> exp_diff;
                    exp_res = exp_a;
                end else if (exp_b > exp_a) begin
                    exp_diff = exp_b - exp_a;
                    mant_a = mant_a >> exp_diff;
                    exp_res = exp_b;
                end else begin
                    exp_res = exp_a;
                end

                if (sign_a == sign_b) begin
                    mant_sum = mant_a + mant_b;
                    sign_res = sign_a;
                end else begin
                    if (mant_a >= mant_b) begin
                        mant_sum = mant_a - mant_b;
                        sign_res = sign_a;
                    end else begin
                        mant_sum = mant_b - mant_a;
                        sign_res = sign_b;
                    end
                end

                if (mant_sum[24]) begin
                    mant_sum = mant_sum >> 1;
                    exp_res  = exp_res + 1;
                end else if (!mant_sum[23] && mant_sum != 0) begin
                    mant_sum = mant_sum << 1;
                    exp_res  = exp_res - 1;
                end

                guard_bit = mant_sum[0];
                lsb_bit   = mant_sum[1];
                did_round = guard_bit & ~lsb_bit;

                flags[2] = (exp_res > exp_max_sel);
                flags[1] = (exp_res < exp_min_sel);
                flags[0] = did_round | guard_bit;  

                if (flags[2])
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (flags[1] || mant_sum==0)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], mant_sum[22:13]};
                else
                    result = {sign_res, exp_res[7:0], mant_sum[22:0]};
            end
        end

   
        2'b10: begin
           

            if (a_is_nan || b_is_nan || (a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (a_is_inf || b_is_inf) begin
                sign_res = sign_a ^ sign_b;
                result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
            end else if (a_is_zero || b_is_zero) begin
                result = {sign_a ^ sign_b, 31'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                product = mant_a * mant_b;
                exp_res = exp_a + exp_b - bias_sel;

                if (product[47]) begin
                    product = product >> 1;
                    exp_res = exp_res + 1;
                end

                frac_mul = product[45:23];
                lsb_bit = product[23];
                guard_bit = product[22];
                sticky_bit = |product[21:0];
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_mul} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow;
                flags[1] = underflow;
                flags[0] = round_inc;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end


        2'b11: begin
           

            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if ((a_is_zero && b_is_zero) || (a_is_inf && b_is_inf)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (b_is_zero) begin
                flags[3] = 1'b1; // div0
                result = mode_fp ? {16'b0, sign_a ^ sign_b, 5'h1F, 10'd0} : {sign_a ^ sign_b, 8'hFF, 23'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                div_numer = {mant_a, 24'b0};
                q = div_numer / mant_b;
                remainder = div_numer % mant_b;
                exp_res = (exp_a - exp_b) + bias_sel;

                if (q[25]) begin
                    q = q >> 1;
                    exp_res = exp_res + 1;
                end else if (!q[24]) begin
                    q = q << 1;
                    exp_res = exp_res - 1;
                end

                frac_div = q[23:1];
                lsb_bit = q[1];
                guard_bit = q[0];
                sticky_bit = (remainder != 0);
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_div} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow;
                flags[1] = underflow;
                flags[0] = guard_bit | sticky_bit;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end
        endcase

        valid_out = 1'b1;
    end
endmodule

XDC:

## ==========================
## CLOCK
## ==========================
set_property PACKAGE_PIN W5 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports clk]

## ==========================
## SWITCHES (SW0-SW15)
## ==========================
# SW15 controla mode_fp (0 = FP32, 1 = FP16)
set_property PACKAGE_PIN R2 [get_ports {sw[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[15]}]

set_property PACKAGE_PIN V17 [get_ports {sw[0]}]
set_property PACKAGE_PIN V16 [get_ports {sw[1]}]
set_property PACKAGE_PIN W16 [get_ports {sw[2]}]
set_property PACKAGE_PIN W17 [get_ports {sw[3]}]
set_property PACKAGE_PIN W15 [get_ports {sw[4]}]
set_property PACKAGE_PIN V15 [get_ports {sw[5]}]
set_property PACKAGE_PIN W14 [get_ports {sw[6]}]
set_property PACKAGE_PIN W13 [get_ports {sw[7]}]
set_property PACKAGE_PIN V2  [get_ports {sw[8]}]
set_property PACKAGE_PIN T3  [get_ports {sw[9]}]
set_property PACKAGE_PIN T2  [get_ports {sw[10]}]
set_property PACKAGE_PIN R3  [get_ports {sw[11]}]
set_property PACKAGE_PIN W2  [get_ports {sw[12]}]
set_property PACKAGE_PIN U1  [get_ports {sw[13]}]
set_property PACKAGE_PIN T1  [get_ports {sw[14]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[*]}]

## ==========================
## BUTTONS
## ==========================
set_property PACKAGE_PIN U18 [get_ports btnC]
set_property PACKAGE_PIN T18 [get_ports btnU]
set_property PACKAGE_PIN T17 [get_ports btnR]
set_property PACKAGE_PIN W19 [get_ports btnL]	
set_property IOSTANDARD LVCMOS33 [get_ports {btnC btnL btnU btnR}]

## ==========================
## LEDS (LD0-LD15)
## ==========================
set_property PACKAGE_PIN U16 [get_ports {led[0]}]
set_property PACKAGE_PIN E19 [get_ports {led[1]}]
set_property PACKAGE_PIN U19 [get_ports {led[2]}]
set_property PACKAGE_PIN V19 [get_ports {led[3]}]
set_property PACKAGE_PIN W18 [get_ports {led[4]}]
set_property PACKAGE_PIN U15 [get_ports {led[5]}]
set_property PACKAGE_PIN U14 [get_ports {led[6]}]
set_property PACKAGE_PIN V14 [get_ports {led[7]}]
set_property PACKAGE_PIN V13 [get_ports {led[8]}]
set_property PACKAGE_PIN V3  [get_ports {led[9]}]
set_property PACKAGE_PIN W3  [get_ports {led[10]}]
set_property PACKAGE_PIN U3  [get_ports {led[11]}]
set_property PACKAGE_PIN P3  [get_ports {led[12]}]
set_property PACKAGE_PIN N3  [get_ports {led[13]}]
set_property PACKAGE_PIN P1  [get_ports {led[14]}]
set_property PACKAGE_PIN L1  [get_ports {led[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[*]}]

## ==========================
## DISPLAY DE 7 SEGMENTOS
## ==========================
set_property PACKAGE_PIN W7 [get_ports {seg[0]}]
set_property PACKAGE_PIN W6 [get_ports {seg[1]}]
set_property PACKAGE_PIN U8 [get_ports {seg[2]}]
set_property PACKAGE_PIN V8 [get_ports {seg[3]}]
set_property PACKAGE_PIN U5 [get_ports {seg[4]}]
set_property PACKAGE_PIN V5 [get_ports {seg[5]}]
set_property PACKAGE_PIN U7 [get_ports {seg[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {seg[*]}]

## Ánodos
set_property PACKAGE_PIN U2 [get_ports {an[0]}]
set_property PACKAGE_PIN U4 [get_ports {an[1]}]
set_property PACKAGE_PIN V4 [get_ports {an[2]}]
set_property PACKAGE_PIN W4 [get_ports {an[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {an[*]}]
