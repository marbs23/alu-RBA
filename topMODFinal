// =====================================================
// 1. Divisor de reloj (más rápido)
// =====================================================
module clk_divider #(parameter DIV = 25_000_00)( // ~0.25s aprox
    input clk, rst,
    output reg slow_clk
);
    reg [31:0] counter = 0;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter >= DIV) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule

// =====================================================
// 2. FSM con nuevo estado para seleccionar modo
// =====================================================
module control_FSM(
    input clk, rst, btnC, btnR, valid_out,
    output reg [2:0] state,
    output reg start
);
    localparam S_MODE=3'd0, S0=3'd1, S1=3'd2, S2=3'd3, S3=3'd4, S4=3'd5, S5=3'd6, S6=3'd7;

    reg [2:0] next_state;

    always @(posedge clk or posedge rst)
        if (rst)
            state <= S_MODE;
        else
            state <= next_state;

    always @(*) begin
        next_state = state;
        case (state)
            S_MODE: if (btnC) next_state = S0;     // Selección de modo
            S0:     if (btnC) next_state = S1;     // op_a[15:0]
            S1:     if (btnC) next_state = S2;     // op_a[31:16]
            S2:     if (btnC) next_state = S3;     // op_b[15:0]
            S3:     if (btnC) next_state = S4;     // op_b[31:16]
            S4:     if (btnC) next_state = S5;     // opcode
            S5:     if (valid_out) next_state = S6;// resultado listo
            S6:     if (btnR) next_state = S_MODE; // reinicio
        endcase
    end

    always @(*) begin
        start = (state == S4 && btnC);
    end
endmodule


// =====================================================
// 3. Top principal con display y selección mode_fp por switch
// =====================================================
module top_FP_ALU_Basys3(
    input clk,
    input btnR, btnC, btnU,
    input [15:0] sw,
    output [15:0] led,
    output [6:0] seg,
    output [3:0] an
);
    // Clock lento (~0.25s)
    wire slow_clk;
    clk_divider #(25_000_00) div(clk, btnR, slow_clk);

    // Señales FSM
    wire [2:0] state;
    wire start;
    wire valid_out;

    // Internos
    reg [31:0] op_a, op_b;
    reg [1:0]  op_code;
    wire [31:0] result;
    wire [4:0]  flags;
    reg mode_fp;   // 0 = 32 bits, 1 = 16 bits

    // FSM
    control_FSM fsm(
        .clk(slow_clk),
        .rst(btnR),
        .btnC(btnC),
        .btnR(btnR),
        .valid_out(valid_out),
        .state(state),
        .start(start)
    );

    // Carga de operandos
    always @(posedge slow_clk or posedge btnR) begin
        if (btnR) begin
            op_a <= 0;
            op_b <= 0;
            op_code <= 0;
            mode_fp <= 1'b0;
        end else begin
            case (state)
                3'd0: mode_fp <= sw[15];                    // ← switch define FP16 (1) o FP32 (0)
                3'd1: if (btnC) op_a[15:0]  <= sw;
                3'd2: if (btnC) op_a[31:16] <= sw;
                3'd3: if (btnC) op_b[15:0]  <= sw;
                3'd4: if (btnC) op_b[31:16] <= sw;
                3'd5: if (btnC) op_code     <= sw[1:0];
            endcase
        end
    end

    // ALU
    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(slow_clk),
        .rst(btnR),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    // Botón U → alternar entre resultado y flags
    reg btnU_sync0, btnU_sync1, show_flags;
    always @(posedge slow_clk or posedge btnR) begin
        if (btnR) begin
            btnU_sync0 <= 0;
            btnU_sync1 <= 0;
            show_flags <= 0;
        end else begin
            btnU_sync0 <= btnU;
            btnU_sync1 <= btnU_sync0;
            if (btnU_sync0 & ~btnU_sync1)
                show_flags <= ~show_flags;
        end
    end

    // LEDs: resultado o flags
    assign led = (show_flags) ? {11'b0, flags} : result[15:0];

    // ==========================================================
    // DISPLAY de tiempo (muestra contador del slow_clk)
    // ==========================================================
    reg [15:0] disp_counter = 0;
    always @(posedge slow_clk or posedge btnR)
        if (btnR) disp_counter <= 0;
        else disp_counter <= disp_counter + 1;

    display7seg disp(
        .clk(clk),
        .num(disp_counter),
        .an(an),
        .seg(seg)
    );
endmodule


// =====================================================
// 4. Módulo para 7 segmentos
// =====================================================
module display7seg(
    input clk,
    input [15:0] num,
    output reg [3:0] an,
    output reg [6:0] seg
);
    reg [1:0] sel = 0;
    reg [3:0] digit;

    always @(posedge clk)
        sel <= sel + 1;

    always @(*) begin
        case (sel)
            2'd0: begin an = 4'b1110; digit = num[3:0];   end
            2'd1: begin an = 4'b1101; digit = num[7:4];   end
            2'd2: begin an = 4'b1011; digit = num[11:8];  end
            2'd3: begin an = 4'b0111; digit = num[15:12]; end
        endcase

        case (digit)
            4'h0: seg = 7'b1000000;
            4'h1: seg = 7'b1111001;
            4'h2: seg = 7'b0100100;
            4'h3: seg = 7'b0110000;
            4'h4: seg = 7'b0011001;
            4'h5: seg = 7'b0010010;
            4'h6: seg = 7'b0000010;
            4'h7: seg = 7'b1111000;
            4'h8: seg = 7'b0000000;
            4'h9: seg = 7'b0010000;
            4'hA: seg = 7'b0001000;
            4'hB: seg = 7'b0000011;
            4'hC: seg = 7'b1000110;
            4'hD: seg = 7'b0100001;
            4'hE: seg = 7'b0000110;
            4'hF: seg = 7'b0001110;
        endcase
    end
endmodule

## ==========================
## CLOCK
## ==========================
set_property PACKAGE_PIN W5 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports clk]

## ==========================
## SWITCHES (SW0–SW15)
## ==========================
# SW15 controla mode_fp (0 = FP32, 1 = FP16)
set_property PACKAGE_PIN R2 [get_ports {sw[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[15]}]

set_property PACKAGE_PIN V17 [get_ports {sw[0]}]
set_property PACKAGE_PIN V16 [get_ports {sw[1]}]
set_property PACKAGE_PIN W16 [get_ports {sw[2]}]
set_property PACKAGE_PIN W17 [get_ports {sw[3]}]
set_property PACKAGE_PIN W15 [get_ports {sw[4]}]
set_property PACKAGE_PIN V15 [get_ports {sw[5]}]
set_property PACKAGE_PIN W14 [get_ports {sw[6]}]
set_property PACKAGE_PIN W13 [get_ports {sw[7]}]
set_property PACKAGE_PIN V2  [get_ports {sw[8]}]
set_property PACKAGE_PIN T3  [get_ports {sw[9]}]
set_property PACKAGE_PIN T2  [get_ports {sw[10]}]
set_property PACKAGE_PIN R3  [get_ports {sw[11]}]
set_property PACKAGE_PIN W2  [get_ports {sw[12]}]
set_property PACKAGE_PIN U1  [get_ports {sw[13]}]
set_property PACKAGE_PIN T1  [get_ports {sw[14]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[*]}]

## ==========================
## BUTTONS
## ==========================
set_property PACKAGE_PIN U18 [get_ports btnC]
set_property PACKAGE_PIN T18 [get_ports btnU]
set_property PACKAGE_PIN T17 [get_ports btnR]
set_property IOSTANDARD LVCMOS33 [get_ports {btnC btnU btnR}]

## ==========================
## LEDS (LD0–LD15)
## ==========================
set_property PACKAGE_PIN U16 [get_ports {led[0]}]
set_property PACKAGE_PIN E19 [get_ports {led[1]}]
set_property PACKAGE_PIN U19 [get_ports {led[2]}]
set_property PACKAGE_PIN V19 [get_ports {led[3]}]
set_property PACKAGE_PIN W18 [get_ports {led[4]}]
set_property PACKAGE_PIN U15 [get_ports {led[5]}]
set_property PACKAGE_PIN U14 [get_ports {led[6]}]
set_property PACKAGE_PIN V14 [get_ports {led[7]}]
set_property PACKAGE_PIN V13 [get_ports {led[8]}]
set_property PACKAGE_PIN V3  [get_ports {led[9]}]
set_property PACKAGE_PIN W3  [get_ports {led[10]}]
set_property PACKAGE_PIN U3  [get_ports {led[11]}]
set_property PACKAGE_PIN P3  [get_ports {led[12]}]
set_property PACKAGE_PIN N3  [get_ports {led[13]}]
set_property PACKAGE_PIN P1  [get_ports {led[14]}]
set_property PACKAGE_PIN L1  [get_ports {led[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[*]}]

## ==========================
## DISPLAY DE 7 SEGMENTOS
## ==========================
set_property PACKAGE_PIN W7 [get_ports {seg[0]}]
set_property PACKAGE_PIN W6 [get_ports {seg[1]}]
set_property PACKAGE_PIN U8 [get_ports {seg[2]}]
set_property PACKAGE_PIN V8 [get_ports {seg[3]}]
set_property PACKAGE_PIN U5 [get_ports {seg[4]}]
set_property PACKAGE_PIN V5 [get_ports {seg[5]}]
set_property PACKAGE_PIN U7 [get_ports {seg[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {seg[*]}]

set_property PACKAGE_PIN U2 [get_ports {an[0]}]
set_property PACKAGE_PIN U4 [get_ports {an[1]}]
set_property PACKAGE_PIN V4 [get_ports {an[2]}]
set_property PACKAGE_PIN W4 [get_ports {an[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {an[*]}]
