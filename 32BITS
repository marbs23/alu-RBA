
module FP_ALU_if (
    input  [31:0] op_a, op_b,
    input  [1:0]  op_code,        
    input         clk, rst,
    input         start,
    input         mode_fp,        
    output reg [31:0] result,
    output reg [4:0]  flags,      
    output reg        valid_out
);

    localparam BIAS     = 8'd127;
    localparam EXP_MIN  = 8'd1;
    localparam EXP_MAX  = 8'd254;

    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;     
    reg [24:0] mant_sum;
    reg [7:0]  exp_diff;

    reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;

    always @(*) begin
        result     = 32'b0;
        flags      = 5'b00000;   
        valid_out  = 1'b0;

        sign_a = op_a[31];
        sign_b = op_b[31];
        exp_a  = op_a[30:23];
        exp_b  = op_b[30:23];
        mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
        mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

        a_is_nan  = (exp_a==8'hFF) && (op_a[22:0]!=0);
      b_is_nan  = (exp_b==8'hFF) && (op_b[22:0]!=0);
        a_is_inf  = (exp_a==8'hFF) && (op_a[22:0]==0);
        b_is_inf  = (exp_b==8'hFF) && (op_b[22:0]==0);
        a_is_zero = (exp_a==8'd0)  && (op_a[22:0]==0);
        b_is_zero = (exp_b==8'd0)  && (op_b[22:0]==0);

        case (op_code)
 
        2'b00, 2'b01: begin
            reg guard_bit, lsb_bit, did_round;

            if (a_is_nan || b_is_nan) begin
                result   = {1'b0, 8'hFF, 23'h400000}; 
            end
            else if (a_is_inf && b_is_inf && (sign_a != (op_code==2'b01 ? ~sign_b : sign_b))) begin
                result   = {1'b0, 8'hFF, 23'h400000};
                flags[4] = 1'b1;
            end
            else if (a_is_inf || b_is_inf) begin
                sign_res = a_is_inf ? sign_a : (op_code==2'b01 ? ~sign_b : sign_b);
                result   = {sign_res, 8'hFF, 23'd0};
            end
            else begin
                if (op_code == 2'b01)
                    sign_b = ~sign_b;

                if (exp_a > exp_b) begin
                    exp_diff = exp_a - exp_b;
                    mant_b = mant_b >> exp_diff;
                    exp_res = exp_a;
                end else if (exp_b > exp_a) begin
                    exp_diff = exp_b - exp_a;
                    mant_a = mant_a >> exp_diff;
                    exp_res = exp_b;
                end else begin
                    exp_res = exp_a;
                end

                if (sign_a == sign_b) begin
                    mant_sum = mant_a + mant_b;
                    sign_res = sign_a;
                end else begin
                    if (mant_a >= mant_b) begin
                        mant_sum = mant_a - mant_b;
                        sign_res = sign_a;
                    end else begin
                        mant_sum = mant_b - mant_a;
                        sign_res = sign_b;
                    end
                end

                if (mant_sum[24]) begin
                    mant_sum = mant_sum >> 1;
                    exp_res  = exp_res + 1;
                end else begin
                    while (mant_sum[23] == 0 && exp_res > 0 && mant_sum!=0) begin
                        mant_sum = mant_sum << 1;
                        exp_res  = exp_res - 1;
                    end
                end

                guard_bit  = mant_sum[0];
                lsb_bit    = mant_sum[1];
                did_round  = 1'b0;

                if (guard_bit && (lsb_bit == 1'b0)) begin
                    mant_sum[23:1] = mant_sum[23:1] + 1'b1;
                    did_round = 1'b1;
                end

                flags[2] = (exp_res > EXP_MAX); 
                flags[1] = (exp_res < EXP_MIN); 
                flags[0] = did_round | guard_bit;

                if (flags[2])
                    result = {sign_res, 8'hFF, 23'd0};
                else if (flags[1] || mant_sum==0)
                    result = {sign_res, 31'd0};
                else
                    result = {sign_res, exp_res[7:0], mant_sum[22:0]};
            end
        end

  
        2'b10: begin
            reg [47:0] product;
            reg [22:0] frac_mul;
            reg [23:0] frac_round;
            reg guard_bit, sticky_bit, lsb_bit;
            reg round_inc;
            reg overflow, underflow;

            if (a_is_nan || b_is_nan) begin
                result = {1'b0, 8'hFF, 23'h400000};
            end
            else if ((a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
                result   = {1'b0, 8'hFF, 23'h400000}; 
                flags[4] = 1'b1;
            end
            else if (a_is_inf || b_is_inf) begin
                sign_res = sign_a ^ sign_b;
                result   = {sign_res, 8'hFF, 23'd0};
            end
            else if (a_is_zero || b_is_zero) begin
                sign_res = sign_a ^ sign_b;
                result   = {sign_res, 31'd0};
            end
            else begin
                sign_res = sign_a ^ sign_b;
                product  = mant_a * mant_b;

                if (product[47]) begin
                    product = product >> 1;
                    exp_res = exp_a + exp_b - (BIAS - 1);
                end else begin
                    exp_res = exp_a + exp_b - BIAS;
                end

                frac_mul   = product[45:23];
                lsb_bit    = product[23];
                guard_bit  = product[22];
                sticky_bit = |product[21:0];
                round_inc  = guard_bit & (sticky_bit | lsb_bit);

                frac_round = {1'b0, frac_mul} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res    = exp_res + 1;
                end

                overflow  = (exp_res > EXP_MAX);
                underflow = (exp_res < EXP_MIN);
                flags[2]  = overflow;
                flags[1]  = underflow;
                flags[0]  = round_inc; 

                if (overflow)
                    result = {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end

2'b11: begin
    reg [47:0] q;                
    reg [47:0] div_numer;
    reg [47:0] remainder;
    reg [22:0] frac_div;
    reg [23:0] frac_round;
    reg guard_bit, sticky_bit, lsb_bit;
    reg round_inc;
    reg overflow, underflow;

    sign_res = sign_a ^ sign_b;

    if (a_is_nan || b_is_nan) begin
        result = {1'b0, 8'hFF, 23'h400000};
    end
    else if ((a_is_zero && b_is_zero) || (a_is_inf && b_is_inf)) begin
        result   = {1'b0, 8'hFF, 23'h400000};
        flags[4] = 1'b1; 
    end
    else if (b_is_zero && !a_is_zero) begin
        result   = {sign_res, 8'hFF, 23'd0};
        flags[3] = 1'b1; 
    end
    else if (a_is_zero && !b_is_zero) begin
        result = {sign_res, 31'd0};
    end
    else if (a_is_inf && !b_is_inf) begin
        result = {sign_res, 8'hFF, 23'd0};
    end
    else if (!a_is_inf && b_is_inf) begin
        result = {sign_res, 31'd0};
    end
    else begin
      
        div_numer = {mant_a, 24'b0}; 
        q         = div_numer / mant_b;
        remainder = div_numer % mant_b;

        exp_res = (exp_a - exp_b) + BIAS;

        
        if (q[25]) begin
            q      = q >> 1;     
            exp_res = exp_res + 1;
        end
        else if (!q[24]) begin
           
            q       = q << 1;
            exp_res = exp_res - 1;
        end

        frac_div   = q[23:1];
        lsb_bit    = q[1];
        guard_bit  = q[0];
        sticky_bit = (remainder != 0); 
      
        round_inc = guard_bit & (sticky_bit | lsb_bit);
        frac_round = {1'b0, frac_div} + round_inc;

        if (frac_round[23]) begin
            frac_round = frac_round >> 1;
            exp_res    = exp_res + 1;
        end

        overflow  = (exp_res > EXP_MAX);
        underflow = (exp_res < EXP_MIN);
        flags[2]  = overflow;
        flags[1]  = underflow;
        flags[0]  = guard_bit | sticky_bit; 

        if (overflow) begin
            result = {sign_res, 8'hFF, 23'd0};
        end
        else if (underflow) begin
            result = {sign_res, 31'd0};
        end
        else begin
            result = {sign_res, exp_res[7:0], frac_round[22:0]};
        end
    end
end


        default: begin
            result = 32'b0;
        end
        endcase

        valid_out = start ? 1'b1 : 1'b0;
    end
endmodule



/////////////////////////////TESTBENCH///////////////////////////////////////
`timescale 1ns/1ps

module tb_FP_ALU_if;

    // Entradas
    reg  [31:0] op_a, op_b;
    reg  [1:0]  op_code;
    reg         start, mode_fp;

    // Salidas
    wire [31:0] result;
    wire [4:0]  flags;
    wire        valid_out;

    // Instancia del DUT
    FP_ALU_if dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(1'b0),
        .rst(1'b0),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    // Task genÃ©rica
    task run_test;
        input [31:0] a, b;
        input [1:0]  op;
        input [80*8:1] desc;
        begin
            op_a = a;
            op_b = b;
            op_code = op;
            start = 1; #5; start = 0;
            #10;
            $display("%s => A=%h  B=%h  op=%b  => R=%h  flags=%b",
                     desc, a, b, op, result, flags);
            #10;
        end
    endtask

    // Bloque principal
    initial begin
        $dumpfile("fp_alu_if_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if);

        mode_fp = 1; start = 0;
        #5;

        // =======================
        // ðŸ”¹ SUMA (op_code = 00)
        // =======================
        $display("\n===== SUMA =====");
        run_test(32'h3F800000, 32'h40000000, 2'b00, "1) 1.0 + 2.0 = 3.0");
        run_test(32'h7F7FFFFF, 32'h7F7FFFFF, 2'b00, "2) MAX + MAX = +Inf (overflow)");

        // =======================
        // ðŸ”¹ RESTA (op_code = 01)
        // =======================
        $display("\n===== RESTA =====");
        run_test(32'h40400000, 32'h3F800000, 2'b01, "1) 3.0 - 1.0 = 2.0");
        run_test(32'h7F800000, 32'h7F800000, 2'b01, "2) +Inf - +Inf = NaN (invalid)");

        // =======================
        // ðŸ”¹ MULTIPLICACIÃ“N (op_code = 10)
        // =======================
        $display("\n===== MULTIPLICACIÃ“N =====");
        run_test(32'h40000000, 32'h3F800000, 2'b10, "1) 2.0 * 1.0 = 2.0");
        run_test(32'h7F800000, 32'h00000000, 2'b10, "2) +Inf * 0.0 = NaN (invalid)");

        // =======================
        // ðŸ”¹ DIVISIÃ“N (op_code = 11)
        // =======================
        $display("\n===== DIVISIÃ“N =====");
        run_test(32'h40000000, 32'h3F800000, 2'b11, "1) 2.0 / 1.0 = 2.0");
        run_test(32'h3F800000, 32'h00000000, 2'b11, "2) 1.0 / 0.0 = +Inf (div0)");

        $display("\n==== FIN DE SIMULACIÃ“N ====");
        $finish;
    end

endmodule
