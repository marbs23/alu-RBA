module FP_ALU_if (
    input  [31:0] op_a, op_b,
    input  [1:0]  op_code,        
    input         clk, rst,
    input         start,
    input         mode_fp,        
    output reg [31:0] result,
    output reg [4:0]  flags,      
    output reg        valid_out
);

    wire [7:0] bias_sel     = mode_fp ? 8'd15  : 8'd127;
    wire [7:0] exp_max_sel  = mode_fp ? 8'd30  : 8'd254;
    wire [7:0] exp_min_sel  = 8'd1;

    // === Variables internas ===
    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;
    reg [24:0] mant_sum;
    reg [7:0]  exp_diff;
    reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;

    always @(*) begin
        result     = 32'b0;
        flags      = 5'b00000;
        valid_out  = 1'b0;

        if (mode_fp) begin
            sign_a = op_a[15];
            sign_b = op_b[15];
            exp_a  = {3'b000, op_a[14:10]};
            exp_b  = {3'b000, op_b[14:10]};
            mant_a = (exp_a[4:0]==5'd0) ? {1'b0, op_a[9:0], 13'b0} : {1'b1, op_a[9:0], 13'b0};
            mant_b = (exp_b[4:0]==5'd0) ? {1'b0, op_b[9:0], 13'b0} : {1'b1, op_b[9:0], 13'b0};

            a_is_nan  = (exp_a[4:0]==5'h1F) && (op_a[9:0]!=0);
            b_is_nan  = (exp_b[4:0]==5'h1F) && (op_b[9:0]!=0);
            a_is_inf  = (exp_a[4:0]==5'h1F) && (op_a[9:0]==0);
            b_is_inf  = (exp_b[4:0]==5'h1F) && (op_b[9:0]==0);
            a_is_zero = (exp_a[4:0]==5'd0)  && (op_a[9:0]==0);
            b_is_zero = (exp_b[4:0]==5'd0)  && (op_b[9:0]==0);
        end else begin
            // --- SINGLE precision (32 bits) ---
            sign_a = op_a[31];
            sign_b = op_b[31];
            exp_a  = op_a[30:23];
            exp_b  = op_b[30:23];
            mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
            mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

            a_is_nan  = (exp_a==8'hFF) && (op_a[22:0]!=0);
            b_is_nan  = (exp_b==8'hFF) && (op_b[22:0]!=0);
            a_is_inf  = (exp_a==8'hFF) && (op_a[22:0]==0);
            b_is_inf  = (exp_b==8'hFF) && (op_b[22:0]==0);
            a_is_zero = (exp_a==8'd0)  && (op_a[22:0]==0);
            b_is_zero = (exp_b==8'd0)  && (op_b[22:0]==0);
        end

        case (op_code)
  
        2'b00, 2'b01: begin
            reg guard_bit, lsb_bit, did_round;

            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1; // invalid
            end else if (a_is_inf && b_is_inf && (sign_a != (op_code==2'b01 ? ~sign_b : sign_b))) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else begin
                if (op_code == 2'b01) sign_b = ~sign_b;

                if (exp_a > exp_b) begin
                    exp_diff = exp_a - exp_b;
                    mant_b = mant_b >> exp_diff;
                    exp_res = exp_a;
                end else if (exp_b > exp_a) begin
                    exp_diff = exp_b - exp_a;
                    mant_a = mant_a >> exp_diff;
                    exp_res = exp_b;
                end else begin
                    exp_res = exp_a;
                end

                if (sign_a == sign_b) begin
                    mant_sum = mant_a + mant_b;
                    sign_res = sign_a;
                end else begin
                    if (mant_a >= mant_b) begin
                        mant_sum = mant_a - mant_b;
                        sign_res = sign_a;
                    end else begin
                        mant_sum = mant_b - mant_a;
                        sign_res = sign_b;
                    end
                end

                if (mant_sum[24]) begin
                    mant_sum = mant_sum >> 1;
                    exp_res  = exp_res + 1;
                end else if (!mant_sum[23] && mant_sum != 0) begin
                    mant_sum = mant_sum << 1;
                    exp_res  = exp_res - 1;
                end

                guard_bit = mant_sum[0];
                lsb_bit   = mant_sum[1];
                did_round = guard_bit & ~lsb_bit;

                flags[2] = (exp_res > exp_max_sel); // overflow
                flags[1] = (exp_res < exp_min_sel); // underflow
                flags[0] = did_round | guard_bit;   // inexact

                if (flags[2])
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (flags[1] || mant_sum==0)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], mant_sum[22:13]};
                else
                    result = {sign_res, exp_res[7:0], mant_sum[22:0]};
            end
        end

    
        2'b10: begin
            reg [47:0] product;
            reg [22:0] frac_mul;
            reg [23:0] frac_round;
            reg guard_bit, sticky_bit, lsb_bit;
            reg round_inc, overflow, underflow;

            if (a_is_nan || b_is_nan || (a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (a_is_inf || b_is_inf) begin
                sign_res = sign_a ^ sign_b;
                result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
            end else if (a_is_zero || b_is_zero) begin
                result = {sign_a ^ sign_b, 31'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                product = mant_a * mant_b;
                exp_res = exp_a + exp_b - bias_sel;

                if (product[47]) begin
                    product = product >> 1;
                    exp_res = exp_res + 1;
                end

                frac_mul = product[45:23];
                lsb_bit = product[23];
                guard_bit = product[22];
                sticky_bit = |product[21:0];
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_mul} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow;
                flags[1] = underflow;
                flags[0] = round_inc;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end


        2'b11: begin
            reg [47:0] q, div_numer, remainder;
            reg [22:0] frac_div;
            reg [23:0] frac_round;
            reg guard_bit, sticky_bit, lsb_bit;
            reg round_inc, overflow, underflow;

            if (a_is_nan || b_is_nan) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if ((a_is_zero && b_is_zero) || (a_is_inf && b_is_inf)) begin
                result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                flags[4] = 1'b1;
            end else if (b_is_zero) begin
                flags[3] = 1'b1; // div0
                result = mode_fp ? {16'b0, sign_a ^ sign_b, 5'h1F, 10'd0} : {sign_a ^ sign_b, 8'hFF, 23'd0};
            end else begin
                sign_res = sign_a ^ sign_b;
                div_numer = {mant_a, 24'b0};
                q = div_numer / mant_b;
                remainder = div_numer % mant_b;
                exp_res = (exp_a - exp_b) + bias_sel;

                if (q[25]) begin
                    q = q >> 1;
                    exp_res = exp_res + 1;
                end else if (!q[24]) begin
                    q = q << 1;
                    exp_res = exp_res - 1;
                end

                frac_div = q[23:1];
                lsb_bit = q[1];
                guard_bit = q[0];
                sticky_bit = (remainder != 0);
                round_inc = guard_bit & (sticky_bit | lsb_bit);
                frac_round = {1'b0, frac_div} + round_inc;

                if (frac_round[23]) begin
                    frac_round = frac_round >> 1;
                    exp_res = exp_res + 1;
                end

                overflow = (exp_res > exp_max_sel);
                underflow = (exp_res < exp_min_sel);
                flags[2] = overflow;
                flags[1] = underflow;
                flags[0] = guard_bit | sticky_bit;

                if (overflow)
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                else if (underflow)
                    result = {sign_res, 31'd0};
                else if (mode_fp)
                    result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                else
                    result = {sign_res, exp_res[7:0], frac_round[22:0]};
            end
        end
        endcase

        valid_out = start;
    end
endmodule


















`timescale 1ns/1ps

module tb_FP_ALU_if;

    // Entradas
    reg  [31:0] op_a, op_b;
    reg  [2:0]  op_code;     // <-- corregido
    reg         start, mode_fp;
    reg         clk, rst;    // <-- agregados

    // Salidas
    wire [31:0] result;
    wire [4:0]  flags;
    wire        valid_out;

    // Generador de clock
    always #5 clk = ~clk;

    // Instancia del DUT
    FP_ALU_if dut (
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(clk),
        .rst(rst),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    // TASK
    task run_test;
        input [31:0] a, b;
        input [2:0] op;
        input [127:0] desc;
        begin
            op_a = a;
            op_b = b;
            op_code = op;
            start = 1; #5; start = 0;
            #20; // tiempo para procesar
            $display("%s => A=%h  B=%h  op=%b  => R=%h  flags=%b", desc, a, b, op, result, flags);
        end
    endtask

    // Bloque principal
    initial begin
        $dumpfile("fp_alu_if_tb.vcd");
        $dumpvars(0, tb_FP_ALU_if);

        clk = 0;
        rst = 0;
        mode_fp = 0; // 1 = FP32, 0 = FP16
        start = 0;
        #10;

               // =====================================================
        // TEST: modo FP16 (half precision)
        // =====================================================
        $display("\n========== TEST FP16 ==========");
        mode_fp = 1;  // activar modo FP16
        #10;

        // Notación FP16 (bits bajos de los 32 bits)
        // 1.0 = 0x3C00, 2.0 = 0x4000, 3.0 = 0x4200, 4.0 = 0x4400
        // 0.5 = 0x3800, -1.0 = 0xBC00, Inf = 0x7C00, -Inf = 0xFC00, NaN = 0x7E00

        // Operaciones básicas
        run_test(32'h00003C00, 32'h00003C00, 3'b000, "L) 1.0 + 1.0 = 2.0 (FP16)");
        run_test(32'h00004000, 32'h00003C00, 3'b001, "M) 2.0 - 1.0 = 1.0 (FP16)");
        run_test(32'h00003C00, 32'h00004000, 3'b010, "N) 1.0 * 2.0 = 2.0 (FP16)");
        run_test(32'h00004000, 32'h00003C00, 3'b011, "O) 2.0 / 1.0 = 2.0 (FP16)");

        // Signos y negativos
        run_test(32'h00003C00, 32'h0000BC00, 3'b000, "P) 1.0 + (-1.0) = 0.0 (FP16)");
        run_test(32'h0000BC00, 32'h00003C00, 3'b001, "Q) -1.0 - 1.0 = -2.0 (FP16)");
        run_test(32'h00003C00, 32'h0000BC00, 3'b010, "R) 1.0 * (-1.0) = -1.0 (FP16)");
        run_test(32'h0000BC00, 32'h00003C00, 3'b011, "S) -1.0 / 1.0 = -1.0 (FP16)");

        // Infinitos
        run_test(32'h00007C00, 32'h00003C00, 3'b000, "T) +Inf + 1.0 = +Inf (FP16)");
        run_test(32'h0000FC00, 32'h0000BC00, 3'b001, "U) -Inf - (-1.0) = -Inf (FP16)");
        run_test(32'h00007C00, 32'h0000FC00, 3'b000, "V) +Inf + -Inf = NaN (FP16)");
        run_test(32'h00003C00, 32'h00000000, 3'b011, "W) 1.0 / 0.0 = +Inf (div0 flag FP16)");

        // Ceros
        run_test(32'h00000000, 32'h00008000, 3'b000, "X) +0 + -0 = +0 (FP16)");
        run_test(32'h00000000, 32'h00008000, 3'b001, "Y) +0 - -0 = +0 (FP16)");

        // Multiplicación y división extremas
        run_test(32'h00004000, 32'h00004000, 3'b010, "Z) 2.0 * 2.0 = 4.0 (FP16)");
        run_test(32'h00003C00, 32'h00004000, 3'b011, "AA) 1.0 / 2.0 = 0.5 (FP16)");

        // Casos con NaN
        run_test(32'h00007E00, 32'h00003C00, 3'b000, "AB) NaN + 1.0 = NaN (FP16)");
        run_test(32'h00003C00, 32'h00007E00, 3'b010, "AC) 1.0 * NaN = NaN (FP16)");
        run_test(32'h00007C00, 32'h00000000, 3'b010, "AD) Inf * 0.0 = NaN (FP16)");

        $display("==== FIN DE SIMULACIÓN ====");
        $finish;

    end

endmodule
