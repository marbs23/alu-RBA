
module clk_divider #(parameter DIV = 50000000)(
input clk, rst,
output reg slow_clk
);
reg [31:0] counter = 0;
always @(posedge clk or posedge rst) begin
if (rst) begin
counter <= 0;
slow_clk <= 0;
end else begin
if (counter == DIV) begin
counter <= 0;
slow_clk <= ~slow_clk;
end else begin
counter <= counter + 1;
end
end
end
endmodule


module top_FP_ALU_Basys3(
input clk, rst,
input [15:0] sw,
input btnC, btnR, btnU,
output [15:0] led
);
wire slow_clk;
clk_divider #(25000000) div(clk, rst, slow_clk);

localparam S0=3'd0, S1=3'd1, S2=3'd2, S3=3'd3, S4=3'd4, S5=3'd5, S6=3'd6;
reg [2:0] state = S0;

reg [31:0] op_a, op_b;
reg [1:0] op_code;
reg start;
wire [31:0] result;
wire [4:0] flags;
wire valid_out;

FP_ALU_if alu(
.op_a(op_a),
.op_b(op_b),
.op_code(op_code),
.clk(slow_clk),
.rst(rst),
.start(start),
.mode_fp(1'b1),
.result(result),
.flags(flags),
.valid_out(valid_out)
);

always @(posedge slow_clk or posedge rst) begin
if (rst) begin
state <= S0;
start <= 0;
op_a <= 0;
op_b <= 0;
end else begin
case (state)
S0: if (btnC) begin op_a[15:0] <= sw; state <= S1; end
S1: if (btnC) begin op_a[31:16] <= sw; state <= S2; end
S2: if (btnC) begin op_b[15:0] <= sw; state <= S3; end
S3: if (btnC) begin op_b[31:16] <= sw; state <= S4; end
S4: if (btnC) begin op_code <= sw[1:0]; start <= 1; state <= S5; end
S5: begin
start <= 0;
if (valid_out) state <= S6;
end
S6: if (btnR) state <= S0;
endcase
end
end

reg show_upper = 0;
always @(posedge btnU) show_upper <= ~show_upper;

assign led = show_upper ? result[31:16] : result[15:0];

endmodule










module FP_ALU_if (
input [31:0] op_a, op_b,
input [1:0] op_code,
input clk, rst,
input start,
input mode_fp,
output reg [31:0] result,
output reg [4:0] flags,
output reg valid_out
);

wire [7:0] bias_sel = mode_fp ? 8'd15 : 8'd127;
wire [7:0] exp_max_sel = mode_fp ? 8'd30 : 8'd254;
wire [7:0] exp_min_sel = 8'd1;

reg sign_a, sign_b, sign_res;
reg [7:0] exp_a, exp_b, exp_res;
reg [23:0] mant_a, mant_b;
reg [24:0] mant_sum;
reg [7:0] exp_diff;
reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;

always @(*) begin
result = 32'b0;
flags = 5'b00000;
valid_out = 1'b0;

if (mode_fp) begin
sign_a = op_a[15];
sign_b = op_b[15];
exp_a = {3'b000, op_a[14:10]};
exp_b = {3'b000, op_b[14:10]};
mant_a = (exp_a[4:0]==5'd0) ? {1'b0, op_a[9:0], 13'b0} : {1'b1, op_a[9:0], 13'b0};
mant_b = (exp_b[4:0]==5'd0) ? {1'b0, op_b[9:0], 13'b0} : {1'b1, op_b[9:0], 13'b0};

a_is_nan = (exp_a[4:0]==5'h1F) && (op_a[9:0]!=0);
b_is_nan = (exp_b[4:0]==5'h1F) && (op_b[9:0]!=0);
a_is_inf = (exp_a[4:0]==5'h1F) && (op_a[9:0]==0);
b_is_inf = (exp_b[4:0]==5'h1F) && (op_b[9:0]==0);
a_is_zero = (exp_a[4:0]==5'd0) && (op_a[9:0]==0);
b_is_zero = (exp_b[4:0]==5'd0) && (op_b[9:0]==0);
end else begin
sign_a = op_a[31];
sign_b = op_b[31];
exp_a = op_a[30:23];
exp_b = op_b[30:23];
mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

a_is_nan = (exp_a==8'hFF) && (op_a[22:0]!=0);
b_is_nan = (exp_b==8'hFF) && (op_b[22:0]!=0);
a_is_inf = (exp_a==8'hFF) && (op_a[22:0]==0);
b_is_inf = (exp_b==8'hFF) && (op_b[22:0]==0);
a_is_zero = (exp_a==8'd0) && (op_a[22:0]==0);
b_is_zero = (exp_b==8'd0) && (op_b[22:0]==0);
end

case (op_code)

2'b00, 2'b01: begin
reg guard_bit, lsb_bit, did_round;

if (a_is_nan || b_is_nan) begin
result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
flags[4] = 1'b1; // invalid
end else if (a_is_inf && b_is_inf && (sign_a != (op_code==2'b01 ? ~sign_b : sign_b))) begin
result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
flags[4] = 1'b1;
end else begin
if (op_code == 2'b01) sign_b = ~sign_b;

if (exp_a > exp_b) begin
exp_diff = exp_a - exp_b;
mant_b = mant_b >> exp_diff;
exp_res = exp_a;
end else if (exp_b > exp_a) begin
exp_diff = exp_b - exp_a;
mant_a = mant_a >> exp_diff;
exp_res = exp_b;
end else begin
exp_res = exp_a;
end

if (sign_a == sign_b) begin
mant_sum = mant_a + mant_b;
sign_res = sign_a;
end else begin
if (mant_a >= mant_b) begin
mant_sum = mant_a - mant_b;
sign_res = sign_a;
end else begin
mant_sum = mant_b - mant_a;
sign_res = sign_b;
end
end

if (mant_sum[24]) begin
mant_sum = mant_sum >> 1;
exp_res = exp_res + 1;
end else if (!mant_sum[23] && mant_sum != 0) begin
mant_sum = mant_sum << 1;
exp_res = exp_res - 1;
end

guard_bit = mant_sum[0];
lsb_bit = mant_sum[1];
did_round = guard_bit & ~lsb_bit;

flags[2] = (exp_res > exp_max_sel);
flags[1] = (exp_res < exp_min_sel);
flags[0] = did_round | guard_bit;

if (flags[2])
result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
else if (flags[1] || mant_sum==0)
result = {sign_res, 31'd0};
else if (mode_fp)
result = {16'b0, sign_res, exp_res[4:0], mant_sum[22:13]};
else
result = {sign_res, exp_res[7:0], mant_sum[22:0]};
end
end


2'b10: begin
reg [47:0] product;
reg [22:0] frac_mul;
reg [23:0] frac_round;
reg guard_bit, sticky_bit, lsb_bit;
reg round_inc, overflow, underflow;

if (a_is_nan || b_is_nan || (a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
flags[4] = 1'b1;
end else if (a_is_inf || b_is_inf) begin
sign_res = sign_a ^ sign_b;
result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
end else if (a_is_zero || b_is_zero) begin
result = {sign_a ^ sign_b, 31'd0};
end else begin
sign_res = sign_a ^ sign_b;
product = mant_a * mant_b;
exp_res = exp_a + exp_b - bias_sel;

if (product[47]) begin
product = product >> 1;
exp_res = exp_res + 1;
end

frac_mul = product[45:23];
lsb_bit = product[23];
guard_bit = product[22];
sticky_bit = |product[21:0];
round_inc = guard_bit & (sticky_bit | lsb_bit);
frac_round = {1'b0, frac_mul} + round_inc;

if (frac_round[23]) begin
frac_round = frac_round >> 1;
exp_res = exp_res + 1;
end

overflow = (exp_res > exp_max_sel);
underflow = (exp_res < exp_min_sel);
flags[2] = overflow;
flags[1] = underflow;
flags[0] = round_inc;

if (overflow)
result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
else if (underflow)
result = {sign_res, 31'd0};
else if (mode_fp)
result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
else
result = {sign_res, exp_res[7:0], frac_round[22:0]};
end
end


2'b11: begin
reg [47:0] q, div_numer, remainder;
reg [22:0] frac_div;
reg [23:0] frac_round;
reg guard_bit, sticky_bit, lsb_bit;
reg round_inc, overflow, underflow;

if (a_is_nan || b_is_nan) begin
result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
flags[4] = 1'b1;
end else if ((a_is_zero && b_is_zero) || (a_is_inf && b_is_inf)) begin
result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
flags[4] = 1'b1;
end else if (b_is_zero) begin
flags[3] = 1'b1; // div0
result = mode_fp ? {16'b0, sign_a ^ sign_b, 5'h1F, 10'd0} : {sign_a ^ sign_b, 8'hFF, 23'd0};
end else begin
sign_res = sign_a ^ sign_b;
div_numer = {mant_a, 24'b0};
q = div_numer / mant_b;
remainder = div_numer % mant_b;
exp_res = (exp_a - exp_b) + bias_sel;

if (q[25]) begin
q = q >> 1;
exp_res = exp_res + 1;
end else if (!q[24]) begin
q = q << 1;
exp_res = exp_res - 1;
end

frac_div = q[23:1];
lsb_bit = q[1];
guard_bit = q[0];
sticky_bit = (remainder != 0);
round_inc = guard_bit & (sticky_bit | lsb_bit);
frac_round = {1'b0, frac_div} + round_inc;

if (frac_round[23]) begin
frac_round = frac_round >> 1;
exp_res = exp_res + 1;
end

overflow = (exp_res > exp_max_sel);
underflow = (exp_res < exp_min_sel);
flags[2] = overflow;
flags[1] = underflow;
flags[0] = guard_bit | sticky_bit;

if (overflow)
result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
else if (underflow)
result = {sign_res, 31'd0};
else if (mode_fp)
result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
else
result = {sign_res, exp_res[7:0], frac_round[22:0]};
end
end
endcase

valid_out = start;
end
endmodule

