// =====================================================
// 1. Divisor de reloj (2 segundos aprox)
// =====================================================
module clk_divider #(parameter DIV = 100_000_000)( // 2 s a 100 MHz
    input clk, rst,
    output reg slow_clk
);
    reg [31:0] counter = 0;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter >= DIV) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule


// =====================================================
// 2. Display para mostrar el estado del clock
// =====================================================
module clk_display(
    input slow_clk,
    output reg [6:0] seg,  // segmentos (a–g)
    output reg [3:0] an    // ánodos del display
);
    always @(*) begin
        an = 4'b1110; // usar solo el dígito más a la derecha
        if (slow_clk)
            seg = 7'b1111001; // “1”
        else
            seg = 7'b0000001; // “0”
    end
endmodule


// =====================================================
// 3. FSM de control
// =====================================================
module control_FSM(
    input clk, rst, btnC, btnR, valid_out,
    output reg [2:0] state,
    output reg start
);
    localparam S0=3'd0, S1=3'd1, S2=3'd2, S3=3'd3, S4=3'd4, S5=3'd5, S6=3'd6;
    reg [2:0] next_state;

    always @(posedge clk or posedge rst)
        if (rst) state <= S0;
        else     state <= next_state;

    always @(*) begin
        next_state = state;
        case (state)
            S0: if (btnC) next_state = S1;
            S1: if (btnC) next_state = S2;
            S2: if (btnC) next_state = S3;
            S3: if (btnC) next_state = S4;
            S4: if (btnC) next_state = S5;
            S5: if (valid_out) next_state = S6;
            S6: if (btnR) next_state = S0;
        endcase
    end

    always @(*) begin
        start = (state == S4 && btnC);
    end
endmodule


// =====================================================
// 4. Top principal (Basys3)
// =====================================================
module top_FP_ALU_Basys3(
    input clk,
    input btnR,          // reset global
    input [15:0] sw,     // switches de entrada
    input btnC,          // confirmar / avanzar FSM
    input btnU,          // mostrar flags
    output [15:0] led,   // LEDs: resultado o flags
    output [6:0] seg,    // display 7 segmentos
    output [3:0] an      // control de ánodos
);
    // Clock lento (~2 s)
    wire slow_clk;
    clk_divider #(100_000_000) div(clk, btnR, slow_clk);

    // FSM
    wire [2:0] state;
    wire start, valid_out;

    reg [31:0] op_a, op_b;
    reg [1:0] op_code;
    reg mode_fp; // 0=FP32, 1=FP16
    wire [31:0] result;
    wire [4:0] flags;

    // FSM de control
    control_FSM fsm(
        .clk(slow_clk),
        .rst(btnR),
        .btnC(btnC),
        .btnR(btnR),
        .valid_out(valid_out),
        .state(state),
        .start(start)
    );

    // ======== Display del clock ========
    clk_display disp(.slow_clk(slow_clk), .seg(seg), .an(an));

    // ======== Entrada de datos ========
    always @(posedge slow_clk or posedge btnR) begin
        if (btnR) begin
            op_a <= 0; op_b <= 0; op_code <= 0; mode_fp <= 0;
        end else begin
            case (state)
                3'd0: if (btnC) mode_fp <= sw[15];   // SW15 selecciona modo
                3'd1: if (btnC) op_a[15:0]  <= sw;
                3'd2: if (btnC) op_a[31:16] <= sw;
                3'd3: if (btnC) op_b[15:0]  <= sw;
                3'd4: if (btnC) op_b[31:16] <= sw;
                3'd5: if (btnC) op_code     <= sw[1:0];
            endcase
        end
    end

    // ======== ALU ========
    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(slow_clk),
        .rst(btnR),
        .start(start),
        .mode_fp(mode_fp),
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

reg btnU_sync0, btnU_sync1;
reg [1:0] show_mode;

always @(posedge slow_clk or posedge btnR) begin
    if (btnR) begin
        btnU_sync0 <= 0;
        btnU_sync1 <= 0;
        show_mode  <= 0;
    end else begin
        btnU_sync0 <= btnU;
        btnU_sync1 <= btnU_sync0;

        if (btnU_sync0 & ~btnU_sync1)
            show_mode <= show_mode + 1; 
    end
end

always @(*) begin
    case (show_mode)
        2'd0: led = result[15:0];      // Parte baja
        2'd1: led = result[31:16];     // Parte alta
        2'd2: led = {11'b0, flags};    // Flags
        default: led = 16'b0;
    endcase
end
endmodule

## ==========================
## CLOCK
## ==========================
set_property PACKAGE_PIN W5 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports clk]

## ==========================
## SWITCHES (SW0–SW15)
## ==========================
# SW15 controla mode_fp (0 = FP32, 1 = FP16)
set_property PACKAGE_PIN R2 [get_ports {sw[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[15]}]

set_property PACKAGE_PIN V17 [get_ports {sw[0]}]
set_property PACKAGE_PIN V16 [get_ports {sw[1]}]
set_property PACKAGE_PIN W16 [get_ports {sw[2]}]
set_property PACKAGE_PIN W17 [get_ports {sw[3]}]
set_property PACKAGE_PIN W15 [get_ports {sw[4]}]
set_property PACKAGE_PIN V15 [get_ports {sw[5]}]
set_property PACKAGE_PIN W14 [get_ports {sw[6]}]
set_property PACKAGE_PIN W13 [get_ports {sw[7]}]
set_property PACKAGE_PIN V2  [get_ports {sw[8]}]
set_property PACKAGE_PIN T3  [get_ports {sw[9]}]
set_property PACKAGE_PIN T2  [get_ports {sw[10]}]
set_property PACKAGE_PIN R3  [get_ports {sw[11]}]
set_property PACKAGE_PIN W2  [get_ports {sw[12]}]
set_property PACKAGE_PIN U1  [get_ports {sw[13]}]
set_property PACKAGE_PIN T1  [get_ports {sw[14]}]
set_property IOSTANDARD LVCMOS33 [get_ports {sw[*]}]

## ==========================
## BUTTONS
## ==========================
set_property PACKAGE_PIN U18 [get_ports btnC]
set_property PACKAGE_PIN T18 [get_ports btnU]
set_property PACKAGE_PIN T17 [get_ports btnR]
set_property IOSTANDARD LVCMOS33 [get_ports {btnC btnU btnR}]

## ==========================
## LEDS (LD0–LD15)
## ==========================
set_property PACKAGE_PIN U16 [get_ports {led[0]}]
set_property PACKAGE_PIN E19 [get_ports {led[1]}]
set_property PACKAGE_PIN U19 [get_ports {led[2]}]
set_property PACKAGE_PIN V19 [get_ports {led[3]}]
set_property PACKAGE_PIN W18 [get_ports {led[4]}]
set_property PACKAGE_PIN U15 [get_ports {led[5]}]
set_property PACKAGE_PIN U14 [get_ports {led[6]}]
set_property PACKAGE_PIN V14 [get_ports {led[7]}]
set_property PACKAGE_PIN V13 [get_ports {led[8]}]
set_property PACKAGE_PIN V3  [get_ports {led[9]}]
set_property PACKAGE_PIN W3  [get_ports {led[10]}]
set_property PACKAGE_PIN U3  [get_ports {led[11]}]
set_property PACKAGE_PIN P3  [get_ports {led[12]}]
set_property PACKAGE_PIN N3  [get_ports {led[13]}]
set_property PACKAGE_PIN P1  [get_ports {led[14]}]
set_property PACKAGE_PIN L1  [get_ports {led[15]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led[*]}]

## ==========================
## DISPLAY DE 7 SEGMENTOS
## ==========================
set_property PACKAGE_PIN W7 [get_ports {seg[0]}]
set_property PACKAGE_PIN W6 [get_ports {seg[1]}]
set_property PACKAGE_PIN U8 [get_ports {seg[2]}]
set_property PACKAGE_PIN V8 [get_ports {seg[3]}]
set_property PACKAGE_PIN U5 [get_ports {seg[4]}]
set_property PACKAGE_PIN V5 [get_ports {seg[5]}]
set_property PACKAGE_PIN U7 [get_ports {seg[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {seg[*]}]

## Ánodos
set_property PACKAGE_PIN U2 [get_ports {an[0]}]
set_property PACKAGE_PIN U4 [get_ports {an[1]}]
set_property PACKAGE_PIN V4 [get_ports {an[2]}]
set_property PACKAGE_PIN W4 [get_ports {an[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {an[*]}]
