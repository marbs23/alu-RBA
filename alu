
module clk_divider #(parameter DIV = 50000000)(
    input clk, rst,
    output reg slow_clk
);
    reg [31:0] counter = 0;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            counter <= 0;
            slow_clk <= 0;
        end else begin
            if (counter == DIV) begin
                counter <= 0;
                slow_clk <= ~slow_clk;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule


module top_FP_ALU_Basys3(
    input clk, rst,
    input [15:0] sw,
    input btnC, btnR, btnU,
    output [15:0] led
);
    wire slow_clk;
    clk_divider #(25000000) div(clk, rst, slow_clk);

    localparam S0=3'd0, S1=3'd1, S2=3'd2, S3=3'd3, S4=3'd4, S5=3'd5, S6=3'd6;
    reg [2:0] state = S0;

    reg [31:0] op_a, op_b;
    reg [1:0]  op_code;
    reg start;
    wire [31:0] result;
    wire [4:0]  flags;
    wire valid_out;

    FP_ALU_if alu(
        .op_a(op_a),
        .op_b(op_b),
        .op_code(op_code),
        .clk(slow_clk),
        .rst(rst),
        .start(start),
        .mode_fp(1'b1),  
        .result(result),
        .flags(flags),
        .valid_out(valid_out)
    );

    always @(posedge slow_clk or posedge rst) begin
        if (rst) begin
            state <= S0;
            start <= 0;
            op_a <= 0;
            op_b <= 0;
        end else begin
            case (state)
                S0: if (btnC) begin op_a[15:0] <= sw; state <= S1; end
                S1: if (btnC) begin op_a[31:16] <= sw; state <= S2; end
                S2: if (btnC) begin op_b[15:0] <= sw; state <= S3; end
                S3: if (btnC) begin op_b[31:16] <= sw; state <= S4; end
                S4: if (btnC) begin op_code <= sw[1:0]; start <= 1; state <= S5; end
                S5: begin
                        start <= 0;
                        if (valid_out) state <= S6;
                    end
                S6: if (btnR) state <= S0;
            endcase
        end
    end

    reg show_upper = 0;
    always @(posedge btnU) show_upper <= ~show_upper;

    assign led = show_upper ? result[31:16] : result[15:0];

endmodule








module FP_div_seq (
    input  clk,
    input  rst,
    input  start,

    input  [23:0] mant_a,
    input  [23:0] mant_b,
    input  [7:0]  exp_a,
    input  [7:0]  exp_b,
    input         sign_a,
    input         sign_b,
    input  [7:0]  bias_sel,
    input  [7:0]  exp_max_sel,
    input  [7:0]  exp_min_sel,
    input         mode_fp,
    input         a_is_nan,
    input         b_is_nan,
    input         a_is_inf,
    input         b_is_inf,
    input         a_is_zero,
    input         b_is_zero,

    output reg [31:0] result,
    output reg [4:0]  flags,
    output reg        done
);

    typedef enum logic [2:0] {
        IDLE        = 3'b000,
        LOAD        = 3'b001,
        DIVIDE      = 3'b010,
        NORMALIZE   = 3'b011,
        ROUND       = 3'b100,
        DONE        = 3'b101
    } state_t;

    state_t state, next_state;

    reg [47:0] remainder, divisor;
    reg [47:0] quotient;
    reg [5:0]  bit_index;
    reg [7:0]  exp_res;
    reg sign_res;
    reg [23:0] frac_round;
    reg guard_bit, sticky_bit, lsb_bit, round_inc;
    reg overflow, underflow;

    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Transiciones de estado
    always @(*) begin
        case (state)
            IDLE:       next_state = start ? LOAD : IDLE;
            LOAD:       next_state = DIVIDE;
            DIVIDE:     next_state = (bit_index == 24) ? NORMALIZE : DIVIDE;
            NORMALIZE:  next_state = ROUND;
            ROUND:      next_state = DONE;
            DONE:       next_state = IDLE;
            default:    next_state = IDLE;
        endcase
    end

    // L칩gica de salida y operaciones
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            result <= 0;
            flags  <= 0;
            done   <= 0;
            bit_index <= 0;
            quotient <= 0;
            remainder <= 0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 0;
                end

                LOAD: begin
                    flags <= 5'b0;
                    quotient <= 0;
                    remainder <= 0;
                    bit_index <= 0;
                    sign_res <= sign_a ^ sign_b;
                    exp_res <= (exp_a - exp_b) + bias_sel;
                    divisor <= {mant_b, 24'b0};
                end

                DIVIDE: begin
                    remainder = {remainder[46:0], mant_a[23 - bit_index]};
                    if (remainder >= divisor) begin
                        remainder = remainder - divisor;
                        quotient = {quotient[46:0], 1'b1};
                    end else begin
                        quotient = {quotient[46:0], 1'b0};
                    end
                    bit_index <= bit_index + 1;
                end

                NORMALIZE: begin
                    if (quotient[47]) begin
                        quotient <= quotient >> 1;
                        exp_res <= exp_res + 1;
                    end else if (!quotient[46]) begin
                        quotient <= quotient << 1;
                        exp_res <= exp_res - 1;
                    end
                end

                ROUND: begin
                    lsb_bit = quotient[22];
                    guard_bit = quotient[21];
                    sticky_bit = |quotient[20:0];
                    round_inc = guard_bit & (sticky_bit | lsb_bit);
                    frac_round = quotient[46:23] + round_inc;

                    overflow = (exp_res > exp_max_sel);
                    underflow = (exp_res < exp_min_sel);
                    flags[2] = overflow;
                    flags[1] = underflow;
                    flags[0] = round_inc;

                    if (overflow)
                        result <= mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0}
                                          : {sign_res, 8'hFF, 23'd0};
                    else if (underflow)
                        result <= {sign_res, 31'd0};
                    else if (mode_fp)
                        result <= {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                    else
                        result <= {sign_res, exp_res[7:0], frac_round[22:0]};
                end

                DONE: begin
                    done <= 1;
                end
            endcase
        end
    end
endmodule












`timescale 1ns/1ps

module FP_ALU_if (
    input  [31:0] op_a, op_b,
    input  [1:0]  op_code,        // 00=add, 01=sub, 10=mul, 11=div
    input         clk, rst,
    input         start,
    input         mode_fp,        // 0: IEEE-754 simple (32-bit), 1: half (16-bit)
    output reg [31:0] result,
    output reg [4:0]  flags,      // [4]=invalid, [3]=div0, [2]=overflow, [1]=underflow, [0]=round
    output reg        valid_out
);

    // Par치metros
    wire [7:0] bias_sel     = mode_fp ? 8'd15  : 8'd127;
    wire [7:0] exp_max_sel  = mode_fp ? 8'd30  : 8'd254;
    wire [7:0] exp_min_sel  = 8'd1;

    // Campos comunes
    reg sign_a, sign_b, sign_res;
    reg [7:0] exp_a, exp_b, exp_res;
    reg [23:0] mant_a, mant_b;
    reg [24:0] mant_sum;
    reg [7:0]  exp_diff;
    reg a_is_nan, b_is_nan, a_is_inf, b_is_inf, a_is_zero, b_is_zero;

    // --- Instancia de divisi칩n secuencial ---
    wire [31:0] div_result;
    wire [4:0]  div_flags;
    wire        div_done;

    FP_div_seq div_unit (
        .clk(clk),
        .rst(rst),
        .start(start && op_code == 2'b11),
        .mant_a(mant_a),
        .mant_b(mant_b),
        .exp_a(exp_a),
        .exp_b(exp_b),
        .sign_a(sign_a),
        .sign_b(sign_b),
        .bias_sel(bias_sel),
        .exp_max_sel(exp_max_sel),
        .exp_min_sel(exp_min_sel),
        .mode_fp(mode_fp),
        .a_is_nan(a_is_nan),
        .b_is_nan(b_is_nan),
        .a_is_inf(a_is_inf),
        .b_is_inf(b_is_inf),
        .a_is_zero(a_is_zero),
        .b_is_zero(b_is_zero),
        .result(div_result),
        .flags(div_flags),
        .done(div_done)
    );

    // -----------------------------------------------------------
    // BLOQUE PRINCIPAL COMBINACIONAL
    // -----------------------------------------------------------
    always @(*) begin
        result     = 32'b0;
        flags      = 5'b00000;
        valid_out  = 1'b0;

        // Descomposici칩n de operandos
        if (mode_fp) begin
            sign_a = op_a[15];
            sign_b = op_b[15];
            exp_a  = {3'b000, op_a[14:10]};
            exp_b  = {3'b000, op_b[14:10]};
            mant_a = (exp_a[4:0]==5'd0) ? {1'b0, op_a[9:0], 13'b0} : {1'b1, op_a[9:0], 13'b0};
            mant_b = (exp_b[4:0]==5'd0) ? {1'b0, op_b[9:0], 13'b0} : {1'b1, op_b[9:0], 13'b0};

            a_is_nan  = (exp_a[4:0]==5'h1F) && (op_a[9:0]!=0);
            b_is_nan  = (exp_b[4:0]==5'h1F) && (op_b[9:0]!=0);
            a_is_inf  = (exp_a[4:0]==5'h1F) && (op_a[9:0]==0);
            b_is_inf  = (exp_b[4:0]==5'h1F) && (op_b[9:0]==0);
            a_is_zero = (exp_a[4:0]==5'd0)  && (op_a[9:0]==0);
            b_is_zero = (exp_b[4:0]==5'd0)  && (op_b[9:0]==0);
        end else begin
            sign_a = op_a[31];
            sign_b = op_b[31];
            exp_a  = op_a[30:23];
            exp_b  = op_b[30:23];
            mant_a = (exp_a==8'd0) ? {1'b0, op_a[22:0]} : {1'b1, op_a[22:0]};
            mant_b = (exp_b==8'd0) ? {1'b0, op_b[22:0]} : {1'b1, op_b[22:0]};

            a_is_nan  = (exp_a==8'hFF) && (op_a[22:0]!=0);
            b_is_nan  = (exp_b==8'hFF) && (op_b[22:0]!=0);
            a_is_inf  = (exp_a==8'hFF) && (op_a[22:0]==0);
            b_is_inf  = (exp_b==8'hFF) && (op_b[22:0]==0);
            a_is_zero = (exp_a==8'd0)  && (op_a[22:0]==0);
            b_is_zero = (exp_b==8'd0)  && (op_b[22:0]==0);
        end

        // -----------------------------------------------------------
        // OPERACIONES
        // -----------------------------------------------------------
        case (op_code)
            // -------------------------------------------------------
            // ADD / SUB
            // -------------------------------------------------------
            2'b00, 2'b01: begin
                reg guard_bit, lsb_bit, did_round;

                if (a_is_nan || b_is_nan) begin
                    result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                    flags[4] = 1'b1;
                end else if (a_is_inf && b_is_inf && (sign_a != (op_code==2'b01 ? ~sign_b : sign_b))) begin
                    result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                    flags[4] = 1'b1;
                end else begin
                    if (op_code == 2'b01) sign_b = ~sign_b;

                    if (exp_a > exp_b) begin
                        exp_diff = exp_a - exp_b;
                        mant_b = mant_b >> exp_diff;
                        exp_res = exp_a;
                    end else if (exp_b > exp_a) begin
                        exp_diff = exp_b - exp_a;
                        mant_a = mant_a >> exp_diff;
                        exp_res = exp_b;
                    end else begin
                        exp_res = exp_a;
                    end

                    if (sign_a == sign_b) begin
                        mant_sum = mant_a + mant_b;
                        sign_res = sign_a;
                    end else begin
                        if (mant_a >= mant_b) begin
                            mant_sum = mant_a - mant_b;
                            sign_res = sign_a;
                        end else begin
                            mant_sum = mant_b - mant_a;
                            sign_res = sign_b;
                        end
                    end

                    if (mant_sum[24]) begin
                        mant_sum = mant_sum >> 1;
                        exp_res  = exp_res + 1;
                    end else if (!mant_sum[23] && mant_sum != 0) begin
                        mant_sum = mant_sum << 1;
                        exp_res  = exp_res - 1;
                    end

                    guard_bit = mant_sum[0];
                    lsb_bit   = mant_sum[1];
                    did_round = guard_bit & ~lsb_bit;

                    flags[2] = (exp_res > exp_max_sel); 
                    flags[1] = (exp_res < exp_min_sel); 
                    flags[0] = did_round | guard_bit;   

                    if (flags[2])
                        result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                    else if (flags[1] || mant_sum==0)
                        result = {sign_res, 31'd0};
                    else if (mode_fp)
                        result = {16'b0, sign_res, exp_res[4:0], mant_sum[22:13]};
                    else
                        result = {sign_res, exp_res[7:0], mant_sum[22:0]};
                end
                valid_out = start;
            end

            // -------------------------------------------------------
            // MUL
            // -------------------------------------------------------
            2'b10: begin
                reg [47:0] product;
                reg [22:0] frac_mul;
                reg [23:0] frac_round;
                reg guard_bit, sticky_bit, lsb_bit;
                reg round_inc, overflow, underflow;

                if (a_is_nan || b_is_nan || (a_is_inf && b_is_zero) || (b_is_inf && a_is_zero)) begin
                    result = mode_fp ? {16'b0, 16'h7E00} : 32'h7FC00000;
                    flags[4] = 1'b1;
                end else if (a_is_inf || b_is_inf) begin
                    sign_res = sign_a ^ sign_b;
                    result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                end else if (a_is_zero || b_is_zero) begin
                    result = {sign_a ^ sign_b, 31'd0};
                end else begin
                    sign_res = sign_a ^ sign_b;
                    product = mant_a * mant_b;
                    exp_res = exp_a + exp_b - bias_sel;

                    if (product[47]) begin
                        product = product >> 1;
                        exp_res = exp_res + 1;
                    end

                    frac_mul = product[45:23];
                    lsb_bit = product[23];
                    guard_bit = product[22];
                    sticky_bit = |product[21:0];
                    round_inc = guard_bit & (sticky_bit | lsb_bit);
                    frac_round = {1'b0, frac_mul} + round_inc;

                    if (frac_round[23]) begin
                        frac_round = frac_round >> 1;
                        exp_res = exp_res + 1;
                    end

                    overflow = (exp_res > exp_max_sel);
                    underflow = (exp_res < exp_min_sel);
                    flags[2] = overflow;
                    flags[1] = underflow;
                    flags[0] = round_inc;

                    if (overflow)
                        result = mode_fp ? {16'b0, sign_res, 5'h1F, 10'd0} : {sign_res, 8'hFF, 23'd0};
                    else if (underflow)
                        result = {sign_res, 31'd0};
                    else if (mode_fp)
                        result = {16'b0, sign_res, exp_res[4:0], frac_round[22:13]};
                    else
                        result = {sign_res, exp_res[7:0], frac_round[22:0]};
                end
                valid_out = start;
            end

            // -------------------------------------------------------
            // DIV (por FSM secuencial)
            // -------------------------------------------------------
            2'b11: begin
                result    = div_result;
                flags     = div_flags;
                valid_out = div_done;
            end
        endcase
    end
endmodule
